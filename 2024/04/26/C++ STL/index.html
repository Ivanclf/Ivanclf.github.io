

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/zhihu.jpg">
  <link rel="icon" href="/img/zhihu.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ivan Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言C++ 标准模板库 (STL, Standard Template Library) ：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).示例：  算法：sort(a.begin(), a.end()) 容器：priority_queue&lt;in">
<meta property="og:type" content="article">
<meta property="og:title" content="算竞常用 C++ STL 用法（转载，排版有改动）">
<meta property="og:url" content="http://example.com/2024/04/26/C++%20STL/index.html">
<meta property="og:site_name" content="Ivanclf">
<meta property="og:description" content="前言C++ 标准模板库 (STL, Standard Template Library) ：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).示例：  算法：sort(a.begin(), a.end()) 容器：priority_queue&lt;in">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-26T15:43:14.000Z">
<meta property="article:modified_time" content="2024-11-16T09:12:58.752Z">
<meta property="article:author" content="Ivan Chen">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="向量">
<meta property="article:tag" content="栈">
<meta property="article:tag" content="堆">
<meta property="article:tag" content="集合">
<meta property="article:tag" content="队列">
<meta property="article:tag" content="映射">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算竞常用 C++ STL 用法（转载，排版有改动） - Ivanclf</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Ivanclf" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ivan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">算竞常用 C++ STL 用法（转载，排版有改动）</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-26 23:43" pubdate>
          2024年4月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算竞常用 C++ STL 用法（转载，排版有改动）</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>C++ 标准模板库 (STL, Standard Template Library)</strong> ：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).<br>示例：</p>
<ul>
<li>算法：<code>sort(a.begin(), a.end())</code></li>
<li>容器：<code>priority_queue&lt;int&gt; pque</code></li>
<li>仿函数：<code>greater&lt;int&gt;()</code></li>
<li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li>
</ul>
<p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <del>往往</del> 更顺利。<br>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。<br>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p>
<h2 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h2><h3 id="内容总览"><a href="#内容总览" class="headerlink" title="内容总览"></a>内容总览</h3><p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p>
<ul>
<li>顺序容器<ul>
<li><input disabled type="checkbox"> <strong>array</strong></li>
<li><input checked disabled type="checkbox"> <a href="#%E5%90%91%E9%87%8F-vector"><strong>vector</strong></a></li>
<li><input disabled type="checkbox"> <strong>deque</strong></li>
<li><input disabled type="checkbox"> forward_list</li>
<li><input disabled type="checkbox"> <strong>list</strong></li>
</ul>
</li>
<li>关联容器<ul>
<li><input checked disabled type="checkbox"> <a href="#%E9%9B%86%E5%90%88-set"><strong>set</strong></a></li>
<li><input checked disabled type="checkbox"> <a href="#%E6%98%A0%E5%B0%84-map"><strong>map</strong></a></li>
<li><input disabled type="checkbox"> <strong>multiset</strong></li>
<li><input disabled type="checkbox"> <strong>multimap</strong></li>
</ul>
</li>
<li>无序关联容器<ul>
<li><input disabled type="checkbox"> <strong>unordered_set</strong></li>
<li><input disabled type="checkbox"> <strong>unordered_map</strong></li>
<li><input disabled type="checkbox"> <strong>unordered_multiset</strong></li>
<li><input disabled type="checkbox"> <strong>unordered_multimap</strong></li>
</ul>
</li>
<li>容器适配器<ul>
<li><input checked disabled type="checkbox"> <a href="#%E6%A0%88-stack"><strong>stack</strong></a></li>
<li><input checked disabled type="checkbox"> <a href="#%E9%98%9F%E5%88%97-queue"><strong>queue</strong></a></li>
<li><input checked disabled type="checkbox"> <a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-priority_queue"><strong>priority_queue</strong></a></li>
<li><input disabled type="checkbox"> flat_set</li>
<li><input disabled type="checkbox"> flat_map</li>
<li><input disabled type="checkbox"> flat_multiset</li>
<li><input disabled type="checkbox"> flat_multimap</li>
</ul>
</li>
<li>字符串<ul>
<li><input checked disabled type="checkbox"> <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-string"><strong>string</strong> (basic_string&lt;char&gt;)</a></li>
</ul>
</li>
<li>对与元组<ul>
<li><input checked disabled type="checkbox"> <a href="#%E4%BA%8C%E5%85%83%E7%BB%84-pair"><strong>pair</strong></a></li>
<li><input disabled type="checkbox"> <strong>tuple</strong></li>
</ul>
</li>
</ul>
<h3 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 vector"></a>向量 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h3><p><strong><code>#include &lt;vector&gt;</code></strong><br>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong><br>时间复杂度：$O(n)$<br>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr;         <span class="hljs-comment">// 构造int数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;    <span class="hljs-comment">// 构造初始长100的int数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 构造初始长100的int数组，初值为1</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mat</span>(<span class="hljs-number">100</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ());       <span class="hljs-comment">// 构造初始100行，不指定列数的二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mat</span>(<span class="hljs-number">100</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">666</span>, <span class="hljs-number">-1</span>)) <span class="hljs-comment">// 构造初始100行，初始666列的二维数组，初值为-1</span><br></code></pre></td></tr></table></figure>

<p>构造二维数组的奇葩写法，千万别用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">100</span>];         <span class="hljs-comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span><br>vector&lt;<span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">100</span>](<span class="hljs-number">100</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 语法错误！</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)</span>[100]</span>; <span class="hljs-comment">// 语法错误！</span><br>vector&lt;<span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">100</span>] &#123;&#123;<span class="hljs-number">100</span>, <span class="hljs-number">1</span>&#125;, 这里省略<span class="hljs-number">98</span>个 ,&#123;<span class="hljs-number">100</span>, <span class="hljs-number">1</span>&#125;&#125;; <span class="hljs-comment">// 正确但奇葩，使用列表初始化</span><br></code></pre></td></tr></table></figure>

<h5 id="尾接-尾删"><a href="#尾接-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h5><ul>
<li>**<code>.push_back(元素)</code>**：在 vector 尾接一个元素，数组长度 $+1$.</li>
<li>**<code>.pop_back()</code>**：删除 vector 尾部的一个元素，数组长度 $-1$</li>
</ul>
<p>时间复杂度：均摊 $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// init: arr = []</span><br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// after: arr = [1]</span><br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// after: arr = [1, 2]</span><br>arr.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// after: arr = [1]</span><br>arr.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// after: arr = []</span><br></code></pre></td></tr></table></figure>

<h5 id="中括号运算符"><a href="#中括号运算符" class="headerlink" title="中括号运算符"></a>中括号运算符</h5><p>和一般数组一样的作用<br>时间复杂度：$O(1)$</p>
<h5 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h5><p><strong><code>.size()</code></strong><br>获取当前 vector 的长度<br>时间复杂度：$O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    cout &lt;&lt; a[i] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h5><p><strong><code>.clear()</code></strong><br>清空 vector<br>时间复杂度：$O(n)$</p>
<h5 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h5><p><strong><code>.empty()</code></strong><br>如果是空返回 <code>true</code> 反之返回 <code>false</code>.<br>时间复杂度：$O(1)$</p>
<h5 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h5><p><strong><code>.resize(新长度, [默认值])</code></strong><br>修改 vector 的长度</p>
<ul>
<li>如果是缩短，则删除多余的值</li>
<li>如果是扩大，且指定了默认值，则新元素均为默认值<strong>（旧元素不变）</strong><br>时间复杂度：$O(n)$</li>
</ul>
<h4 id="适用情形"><a href="#适用情形" class="headerlink" title="适用情形"></a>适用情形</h4><p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。<br>有些情况普通数组没法解决：$n\times m$ 的矩阵，$1\leq n,m\leq 10^6$ 且 $n\times m \leq 10^6$</p>
<ul>
<li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li>
<li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。<br>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="提前指定长度"><a href="#提前指定长度" class="headerlink" title="提前指定长度"></a>提前指定长度</h5><p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化前: 522ms</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e8</span>; i++)<br>    a.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-comment">// 优化后: 259ms</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1e8</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)<br>    a[i] = i;<br></code></pre></td></tr></table></figure>

<h5 id="当心-size-t-溢出"><a href="#当心-size-t-溢出" class="headerlink" title="当心 size_t 溢出"></a>当心 size_t 溢出</h5><p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">65536</span>)</span></span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a = a.<span class="hljs-built_in">size</span>() * a.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 直接溢出变成0了</span><br></code></pre></td></tr></table></figure>

<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h3><p><strong><code>#include &lt;stack&gt;</code></strong><br>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>构造</td>
<td><code>stack&lt;类型&gt; stk</code></td>
<td><code>stack&lt;int&gt; stk;</code></td>
</tr>
<tr>
<td>进栈</td>
<td><code>.push(元素)</code></td>
<td><code>stk.push(1);</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>.pop()</code></td>
<td><code>stk.pop();</code></td>
</tr>
<tr>
<td>取栈顶</td>
<td><code>.top()</code></td>
<td><code>int a = stk.top();</code></td>
</tr>
<tr>
<td>查看大小 &#x2F; 清空 &#x2F; 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody></table>
<h4 id="适用情形-1"><a href="#适用情形-1" class="headerlink" title="适用情形"></a>适用情形</h4><p>如果不卡常的话，就可以直接用它而不需要手写栈了。<br>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>不可访问内部元素！<strong>下面都是错误用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stk.<span class="hljs-built_in">size</span>(); i++)<br>    cout &lt;&lt; stk[i] &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ele : stk)<br>    cout &lt;&lt; stk &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h3><p><strong><code>#include &lt;queue&gt;</code></strong><br>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>构造</td>
<td><code>queue&lt;类型&gt; que</code></td>
<td><code>queue&lt;int&gt; que;</code></td>
</tr>
<tr>
<td>进队</td>
<td><code>.push(元素)</code></td>
<td><code>que.push(1);</code></td>
</tr>
<tr>
<td>出队</td>
<td><code>.pop()</code></td>
<td><code>que.pop();</code></td>
</tr>
<tr>
<td>取队首</td>
<td><code>.front()</code></td>
<td><code>int a = que.front();</code></td>
</tr>
<tr>
<td>取队尾</td>
<td><code>.back()</code></td>
<td><code>int a = que.back();</code></td>
</tr>
<tr>
<td>查看大小 &#x2F; 清空 &#x2F; 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody></table>
<h4 id="适用情形-2"><a href="#适用情形-2" class="headerlink" title="适用情形"></a>适用情形</h4><p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p>不可访问内部元素！<strong>下面都是错误用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; que.<span class="hljs-built_in">size</span>(); i++)<br>    cout &lt;&lt; que[i] &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ele : que)<br>    cout &lt;&lt; ele &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h3><p><strong><code>#include &lt;queue&gt;</code></strong><br>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p>
<ul>
<li>类型：要储存的数据类型</li>
<li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li>
<li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; pque1;                            <span class="hljs-comment">// 储存int的大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pque2; <span class="hljs-comment">// 储存int的小顶堆</span><br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p>
          </div>

<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>进堆</td>
<td><code>.push(元素)</code></td>
<td><code>que.push(1);</code></td>
</tr>
<tr>
<td>出堆</td>
<td><code>.pop()</code></td>
<td><code>que.pop();</code></td>
</tr>
<tr>
<td>取堆顶</td>
<td><code>.top()</code></td>
<td><code>int a = que.top();</code></td>
</tr>
<tr>
<td>查看大小 &#x2F; 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody></table>
<p>进出队复杂度 $O(\log n)$，取堆顶 $O(1)$.</p>
<h4 id="适用情形-3"><a href="#适用情形-3" class="headerlink" title="适用情形"></a>适用情形</h4><p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小&#x2F;最大的元素，元素数量 $n$，插入操作数量 $k$.</p>
<ul>
<li>每次插入后进行快速排序：$k\cdot n\log n$</li>
<li>使用优先队列维护：$k\cdot\log n$</li>
</ul>
<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="仅堆顶可读"><a href="#仅堆顶可读" class="headerlink" title="仅堆顶可读"></a>仅堆顶可读</h5><p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; pque[<span class="hljs-number">1</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id="所有元素不可写"><a href="#所有元素不可写" class="headerlink" title="所有元素不可写"></a>所有元素不可写</h5><p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pque[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>pque.<span class="hljs-built_in">top</span>() = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tp = pque.<span class="hljs-built_in">top</span>();<br>pque.<span class="hljs-built_in">pop</span>();<br>pque.<span class="hljs-built_in">push</span>(tp + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/set">set</a></h3><p><strong><code>#include &lt;set&gt;</code></strong><br>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p>
<table>
<thead>
<tr>
<th>集合三要素</th>
<th>解释</th>
<th>set</th>
<th>multiset</th>
<th>unordered_set</th>
</tr>
</thead>
<tbody><tr>
<td>确定性</td>
<td>一个元素要么在集合中，要么不在</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>互异性</td>
<td>一个元素仅可以在集合中出现一次</td>
<td>✔</td>
<td>❌（任意次）</td>
<td>✔</td>
</tr>
<tr>
<td>无序性</td>
<td>集合中的元素是没有顺序的</td>
<td>❌（从小到大）</td>
<td>❌（从小到大）</td>
<td>✔</td>
</tr>
</tbody></table>
<h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h5><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p>
<ul>
<li>类型：要储存的数据类型</li>
<li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; st1;               <span class="hljs-comment">// 储存int的集合（从小到大）</span><br>set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; st2; <span class="hljs-comment">// 储存int的集合（从大到小）</span><br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。</p>
          </div>

<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>可使用迭代器进行遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); ++it)<br>    cout &lt;&lt; *it &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>基于范围的循环（C++ 11）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ele : st)<br>    cout &lt;&lt; ele &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td><code>.insert(元素)</code></td>
<td><code>st.insert(1);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>.erase(元素)</code></td>
<td><code>st.erase(2);</code></td>
</tr>
<tr>
<td>查找元素</td>
<td><code>.find(元素)</code></td>
<td><code>auto it = st.find(1);</code></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td><code>.count(元素)</code></td>
<td><code>st.count(3);</code></td>
</tr>
<tr>
<td>查看大小 &#x2F; 清空 &#x2F; 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody></table>
<p>增删查时间复杂度均为 $O(\log n)$</p>
<h4 id="适用情形-4"><a href="#适用情形-4" class="headerlink" title="适用情形"></a>适用情形</h4><ul>
<li>元素去重：$[1,1,3,2,4,4]\to[1,2,3,4]$</li>
<li>维护顺序：$[1,5,3,7,9]\to[1,3,5,7,9]$</li>
<li>元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。</li>
</ul>
<h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="不存在下标索引"><a href="#不存在下标索引" class="headerlink" title="不存在下标索引"></a>不存在下标索引</h5><p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; st[<span class="hljs-number">0</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h5><p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; *st.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">// 正确。可读。</span><br>*st.<span class="hljs-built_in">begin</span>() = <span class="hljs-number">1</span>;             <span class="hljs-comment">// 错误！不可写！</span><br></code></pre></td></tr></table></figure>

<h5 id="不可用迭代器计算下标"><a href="#不可用迭代器计算下标" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h5><p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 正确，返回2所在位置的迭代器。</span><br><span class="hljs-type">int</span> idx = it - st.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 错误！不可相减得到下标。</span><br></code></pre></td></tr></table></figure>

<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map">map</a></h3><p><strong><code>#include &lt;map&gt;</code></strong><br>提供对数时间的有序键值对结构。底层原理是红黑树。<br>映射：<br>$$<br>\begin{matrix}<br>1&amp;\to&amp;2\<br>2&amp;\to&amp;2\<br>3&amp;\to&amp;1\<br>4&amp;\to&amp;5\<br>&amp;\vdots<br>\end{matrix}<br>$$</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>解释</th>
<th>map</th>
<th>multimap</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody><tr>
<td>互异性</td>
<td>一个键仅可以在映射中出现一次</td>
<td>✔</td>
<td>❌（任意次）</td>
<td>✔</td>
</tr>
<tr>
<td>无序性</td>
<td>键是没有顺序的</td>
<td>❌（从小到大）</td>
<td>❌（从小到大）</td>
<td>✔</td>
</tr>
</tbody></table>
<h4 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h5><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p>
<ul>
<li>键类型：要储存键的数据类型</li>
<li>值类型：要储存值的数据类型</li>
<li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp1;               <span class="hljs-comment">// int-&gt;int 的映射（键从小到大）</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; st2; <span class="hljs-comment">// int-&gt;int 的映射（键从大到小）</span><br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。</p>
          </div>

<h5 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h5><p>可使用迭代器进行遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>(); ++it)<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>基于范围的循环（C++ 11）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pr : mp)<br>    cout &lt;&lt; pr.first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>结构化绑定 + 基于范围的循环（C++17）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[key, val] : mp)<br>    cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>增 &#x2F; 改 &#x2F; 查元素</td>
<td>中括号</td>
<td><code>mp[1] = 2;</code></td>
</tr>
<tr>
<td>查元素（返回迭代器）</td>
<td><code>.find(元素)</code></td>
<td><code>auto it = mp.find(1);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>.erase(元素)</code></td>
<td><code>mp.erase(2);</code></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td><code>.count(元素)</code></td>
<td><code>mp.count(3);</code></td>
</tr>
<tr>
<td>查看大小 &#x2F; 清空 &#x2F; 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody></table>
<p>增删改查时间复杂度均为 $O(\log n)$</p>
<h4 id="适用情形-5"><a href="#适用情形-5" class="headerlink" title="适用情形"></a>适用情形</h4><p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p>
<h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="中括号访问时默认值"><a href="#中括号访问时默认值" class="headerlink" title="中括号访问时默认值"></a>中括号访问时默认值</h5><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>cout &lt;&lt; mp.<span class="hljs-built_in">count</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>mp[<span class="hljs-string">&#x27;a&#x27;</span>];                       <span class="hljs-comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span><br>cout &lt;&lt; mp.<span class="hljs-built_in">count</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>cout &lt;&lt; mp[<span class="hljs-string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

<h5 id="不可用迭代器计算下标-1"><a href="#不可用迭代器计算下标-1" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h5><p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);      <span class="hljs-comment">// 正确，返回2所在位置的迭代器。</span><br><span class="hljs-type">int</span> idx = it - mp.<span class="hljs-built_in">begin</span>();   <span class="hljs-comment">// 错误！不可相减得到下标。</span><br></code></pre></td></tr></table></figure>

<h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/string">string</a></h3><p><strong><code>#include &lt;string&gt;</code></strong><br>顾名思义，就是储存字符串的。</p>
<h4 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h5><p>构造函数：<code>string(长度, 初值)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1;           <span class="hljs-comment">// 构造字符串，为空</span><br>string s2 = <span class="hljs-string">&quot;awa!&quot;</span>;  <span class="hljs-comment">// 构造字符串，并赋值awa!</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;6&#x27;</span>)</span></span>;  <span class="hljs-comment">// 构造字符串，通过构造函数构造为6666666666</span><br></code></pre></td></tr></table></figure>

<h5 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h5><p>C++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br>cin &gt;&gt; s;<br>cout &lt;&lt; s;<br></code></pre></td></tr></table></figure>

<p>C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;buf);<br>s = buf;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure>

<h5 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>修改、查询指定下标字符</td>
<td><code>[]</code></td>
<td><code>s[1] = &#39;a&#39;;</code></td>
</tr>
<tr>
<td>是否相同</td>
<td><code>==</code></td>
<td><code>if (s1 == s2) ...</code></td>
</tr>
<tr>
<td>字符串连接</td>
<td><code>+</code></td>
<td><code>string s = s1 + s2;</code></td>
</tr>
<tr>
<td>尾接字符串</td>
<td><code>+=</code></td>
<td><code>s += &quot;awa&quot;;</code></td>
</tr>
<tr>
<td>取子串</td>
<td><code>.substr(起始下标, 子串长度)</code></td>
<td><code>string sub = s.substr(2, 10);</code></td>
</tr>
<tr>
<td>查找字符串</td>
<td><code>.find(字符串, 起始下标)</code></td>
<td><code>int pos = s.find(&quot;awa&quot;);</code></td>
</tr>
</tbody></table>
<h5 id="数值与字符串互转（C-11）"><a href="#数值与字符串互转（C-11）" class="headerlink" title="数值与字符串互转（C++11）"></a>数值与字符串互转（C++11）</h5><table>
<thead>
<tr>
<th>源</th>
<th>目的</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>int &#x2F; long long &#x2F; float &#x2F; double &#x2F; long double</td>
<td>string</td>
<td>to_string()</td>
</tr>
<tr>
<td>string</td>
<td>int</td>
<td>stoi()</td>
</tr>
<tr>
<td>string</td>
<td>long long</td>
<td>stoll()</td>
</tr>
<tr>
<td>string</td>
<td>float</td>
<td>stof()</td>
</tr>
<tr>
<td>string</td>
<td>double</td>
<td>stod()</td>
</tr>
<tr>
<td>string</td>
<td>long double</td>
<td>stold()</td>
</tr>
</tbody></table>
<h4 id="适用情形-6"><a href="#适用情形-6" class="headerlink" title="适用情形"></a>适用情形</h4><p>非常好用！<del>建议直接把字符数组扔了，赶快投入 string 的怀抱。</del></p>
<h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="尾接字符串一定要用"><a href="#尾接字符串一定要用" class="headerlink" title="尾接字符串一定要用 +="></a>尾接字符串一定要用 <code>+=</code></h5><p>string 的 +&#x3D; 运算符，将会在原字符串原地尾接字符串。而 + 了再 &#x3D; 赋值，会先生成一个临时变量，在复制给 string.<br>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化前: 15139ms</span><br>string s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5e5</span>; i++)<br>    s = s + <span class="hljs-string">&quot;a&quot;</span>;<br><br><span class="hljs-comment">// 优化后: &lt; 1ms (计时器显示0)</span><br>string s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5e5</span>; i++)<br>    s += <span class="hljs-string">&quot;a&quot;</span>;<br></code></pre></td></tr></table></figure>

<h5 id="substr-方法的奇葩参数"><a href="#substr-方法的奇葩参数" class="headerlink" title=".substr() 方法的奇葩参数"></a><code>.substr()</code> 方法的奇葩参数</h5><p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。<br>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p>
<h5 id="find-方法的复杂度"><a href="#find-方法的复杂度" class="headerlink" title=".find() 方法的复杂度"></a><code>.find()</code> 方法的复杂度</h5><p>该方法实现为暴力实现，时间复杂度为 $O(n^2)$.<br><del>不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法</del></p>
<h3 id="二元组-pair"><a href="#二元组-pair" class="headerlink" title="二元组 pair"></a>二元组 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h3><p><strong><code>#include &lt;utility&gt;</code></strong><br>顾名思义，就是储存二元组的。</p>
<h4 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h5><p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p>
<ul>
<li>第一个值类型：要储存的第一个值的数据类型</li>
<li>第二个值类型：要储存的第二个值的数据类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p1;<br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; p2;<br>pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; p3;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>老式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; pr = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>列表构造 C++11</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; pr = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h5><p>直接取值</p>
<ul>
<li>取第一个值：<code>.first</code></li>
<li>取第二个值：<code>.second</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; pr = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;;<br><span class="hljs-type">int</span> awa = pr.first;<br><span class="hljs-type">char</span> bwb = pr.second;<br></code></pre></td></tr></table></figure>

<p>结构化绑定 C++17</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; pr = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;;<br><span class="hljs-keyword">auto</span> &amp;[awa, bwb] = pr;<br></code></pre></td></tr></table></figure>

<h5 id="判同"><a href="#判同" class="headerlink" title="判同"></a>判同</h5><p>直接用 <code>==</code> 运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">if</span> (p1 == p2) &#123; ... &#125; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p>
<h2 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h2><h3 id="迭代器是什么？"><a href="#迭代器是什么？" class="headerlink" title="迭代器是什么？"></a>迭代器是什么？</h3><p>不搞抽象，直接举例。<br>对于一个 vector，我们可以用下标遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)<br>    cout &lt;&lt; a[i] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>我们同时也可以用迭代器来遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); ++it)<br>    cout &lt;&lt; *it &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li>
<li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li>
<li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li>
<li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li>
</ul>
<h3 id="为何需要迭代器？"><a href="#为何需要迭代器？" class="headerlink" title="为何需要迭代器？"></a>为何需要迭代器？</h3><p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。<br>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。<br>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); ++it)<br>    cout &lt;&lt; *it &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="迭代器用法"><a href="#迭代器用法" class="headerlink" title="迭代器用法"></a>迭代器用法</h3><p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p>
<ul>
<li><code>.begin()</code>：头迭代器</li>
<li><code>.end()</code>：尾迭代器</li>
<li><code>.rbegin()</code>：反向头迭代器</li>
<li><code>.rend()</code>：反向尾迭代器</li>
<li>迭代器 <code>+</code> 整型：将迭代器向后移动</li>
<li>迭代器 <code>-</code> 整型：将迭代器向前移动</li>
<li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li>
<li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li>
<li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li>
<li><code>prev(it)</code>：返回 it 的前一个迭代器</li>
<li><code>next(it)</code>：返回 it 的后一个迭代器<br>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong><br>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的<br>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的<br><strong>不同容器的迭代器功能可能不一样</strong><br>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。<br><strong>删除操作时需要警惕</strong></p>
<p>为什么 3 没删掉？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); ++it)<br>    <span class="hljs-keyword">if</span> (*it == <span class="hljs-number">2</span> || *it == <span class="hljs-number">3</span>)<br>        a.<span class="hljs-built_in">erase</span>(it);<br><span class="hljs-comment">// a = [1, 3, 4]</span><br></code></pre></td></tr></table></figure>

<p>为啥 RE 了？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); ++it)<br>    <span class="hljs-keyword">if</span> (*it == <span class="hljs-number">4</span>)<br>        a.<span class="hljs-built_in">erase</span>(it);<br></code></pre></td></tr></table></figure>

<center><b>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</b></center>

<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="内容总览-1"><a href="#内容总览-1" class="headerlink" title="内容总览"></a>内容总览</h3><p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。<br>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p>
<ul>
<li><p>算法库 Algorithm</p>
<ul>
<li><input disabled type="checkbox"> <code>count()</code></li>
<li><input disabled type="checkbox"> <code>find()</code></li>
<li><input disabled type="checkbox"> <code>fill()</code></li>
<li><input checked disabled type="checkbox"> <a href="#swap"><code>swap()</code></a></li>
<li><input checked disabled type="checkbox"> <a href="#reverse"><code>reverse()</code></a></li>
<li><input disabled type="checkbox"> <code>shuffle()</code> C++11</li>
<li><input checked disabled type="checkbox"> <a href="#unique"><code>unique()</code></a></li>
<li><input checked disabled type="checkbox"> <a href="#sort"><code>sort()</code></a></li>
<li><input checked disabled type="checkbox"> <a href="#lower_bound--upper_bound"><code>lower_bound()</code> &#x2F; <code>upper_bound()</code></a></li>
<li><input checked disabled type="checkbox"> <a href="#max--min"><code>max()</code> &#x2F; <code>min()</code></a></li>
<li><input disabled type="checkbox"> <code>max_element()</code> &#x2F; <code>min_element()</code></li>
<li><input disabled type="checkbox"> <code>prev_permutation()</code> &#x2F; <code>next_permutation()</code></li>
</ul>
</li>
<li><p>数学函数 cmath</p>
<ul>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> &#x2F; <code>log10()</code> &#x2F; <code>log2()</code></li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li>
<li><input disabled type="checkbox"> <code>sin()</code> &#x2F; <code>cos()</code> &#x2F; <code>tan()</code></li>
<li><input disabled type="checkbox"> <code>asin()</code> &#x2F; <code>acos()</code> &#x2F; <code>atan()</code></li>
<li><input disabled type="checkbox"> <code>sinh()</code> &#x2F; <code>cosh()</code> &#x2F; <code>tanh()</code></li>
<li><input disabled type="checkbox"> <code>asinh()</code> &#x2F; <code>acosh()</code> &#x2F; <code>atanh()</code> C++11</li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> &#x2F; <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li>
</ul>
</li>
<li><p>数值算法 numeric</p>
<ul>
<li><input disabled type="checkbox"> <code>iota()</code> C++11</li>
<li><input disabled type="checkbox"> <code>accumulate()</code></li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li>
<li><input checked disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li>
</ul>
</li>
<li><p>伪随机数生成 random</p>
<ul>
<li><input disabled type="checkbox"> <code>mt19937</code></li>
<li><input disabled type="checkbox"> <code>random_device()</code></li>
</ul>
</li>
</ul>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap()"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></h3><p>交换两个变量的值<br><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">( T&amp; a, T&amp; b )</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">swap</span>(a, b);<br><span class="hljs-comment">// now a = 1, b = 0</span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">4</span>], arr[<span class="hljs-number">6</span>]);<br><span class="hljs-comment">// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>注意事项</strong><br>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></h3><p>使用快速排序给一个可迭代对象排序<br><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> RandomIt, <span class="hljs-keyword">class</span> Compare &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;<br></code></pre></td></tr></table></figure>

<p>默认排序从小到大</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span><br></code></pre></td></tr></table></figure>

<p>如果要从大到小，则需要传比较器进去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span><br></code></pre></td></tr></table></figure>

<p>如果需要完成特殊比较，则需要手写比较器。<br>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\star$：</p>
<ul>
<li>若 $a\star b$，则比较器函数应当返回 <code>true</code></li>
<li>若 $a\not\star b$，则比较器函数应当返回 <code>false</code></li>
</ul>
<p><b>注意：</b>如果 $a&#x3D;b$，比较器函数必须返回 <code>false</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; a, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.second != b.second)<br>        <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>    <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; arr&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;;<br> <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound() &#x2F; upper_bound()"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> &#x2F; <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></h3><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p>
<ul>
<li><code>lower_bound()</code>: 寻找 $\geq x$ 的第一个元素的位置</li>
<li><code>upper_bound()</code>: 寻找 $&gt;x$ 的第一个元素的位置</li>
</ul>
<p>怎么找 $\leq x$ &#x2F; $&lt; x$ 的第一个元素呢？</p>
<ul>
<li>$&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\leq x$ 的第一个元素</li>
<li>$\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素</li>
</ul>
<p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。<br><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">7</span>);<br><span class="hljs-type">int</span> idx = it - arr.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// idx = 4</span><br></code></pre></td></tr></table></figure>

<p>我们通常写成一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>&#125;;<br>idx = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">7</span>) - arr.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 4</span><br>idx = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">8</span>) - arr.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 4</span><br>idx = <span class="hljs-built_in">upper_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">7</span>) - arr.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 4</span><br>idx = <span class="hljs-built_in">upper_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">8</span>) - arr.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></h3><p>反转一个可迭代对象的元素顺序<br><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> BidirIt &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">( BidirIt first, BidirIt last )</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-built_in">iota</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span><br><span class="hljs-built_in">reverse</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span><br></code></pre></td></tr></table></figure>

<h3 id="max-min"><a href="#max-min" class="headerlink" title="max() &#x2F; min()"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> &#x2F; <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></h3><p>返回最大值 &#x2F; 最小值的<strong>数值</strong><br><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> mx = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-type">int</span> mn = <span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Before C++11</span><br><span class="hljs-type">int</span> mx = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 4</span><br><span class="hljs-type">int</span> mn = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-built_in">min</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// After C++11</span><br><span class="hljs-type">int</span> mx = <span class="hljs-built_in">max</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;); <span class="hljs-comment">// 4</span><br><span class="hljs-type">int</span> mn = <span class="hljs-built_in">min</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<h3 id="unique"><a href="#unique" class="headerlink" title="unique()"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></h3><p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。<br>例如：$[1,1,4,5,1,4]\to[1,4,5,1,4,\underline?]$，下划线位置为返回的迭代器指向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">unique</span><span class="hljs-params">( ForwardIt first, ForwardIt last )</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>用法示例</strong><br>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。<br>但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\to[1,2,4,5,\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.<br>最终，给 vector 去重的写法便是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>arr.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>()), arr.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>所有函数参数均支持 <code>int</code> &#x2F; <code>long long</code> &#x2F; <code>float</code> &#x2F; <code>double</code> &#x2F; <code>long double</code></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)&#x3D;\lvert x\rvert$</td>
<td><code>abs(-1.0)</code></td>
</tr>
<tr>
<td>$f(x)&#x3D;e^x$</td>
<td><code>exp(2)</code></td>
</tr>
<tr>
<td>$f(x)&#x3D;\ln x$</td>
<td><code>log(3)</code></td>
</tr>
<tr>
<td>$f(x,y)&#x3D;x^y$</td>
<td><code>pow(2, 3)</code></td>
</tr>
<tr>
<td>$f(x)&#x3D;\sqrt x$</td>
<td><code>sqrt(2)</code></td>
</tr>
<tr>
<td>$f(x)&#x3D;\lceil x\rceil$</td>
<td><code>ceil(2.1)</code></td>
</tr>
<tr>
<td>$f(x)&#x3D;\lfloor x\rfloor$</td>
<td><code>floor(2.1)</code></td>
</tr>
<tr>
<td>$f(x)&#x3D;\left&lt;x\right&gt;$</td>
<td><code>rount(2.1)</code></td>
</tr>
</tbody></table>
<p><strong>注意事项</strong><br>由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。</p>
<div class="note note-info">
            <p>原文地址：<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/107717">https://codeforces.com/blog/entry/107717</a></p>
          </div>

<ul>
<li>$\lfloor\frac{a}{b}\rfloor$<ul>
<li>别用：<code>floor(1.0 * a / b)</code></li>
<li>要用：<code>a / b</code></li>
</ul>
</li>
<li>$\lceil\frac{a}{b}\rceil$<ul>
<li>别用：<code>ceil(1.0 * a / b)</code></li>
<li>要用：<code>(a + b - 1) / b</code>  （$\lceil\frac{a}{b}\rceil&#x3D;\lfloor\frac{a+b-1}{b}\rfloor$）</li>
</ul>
</li>
<li>$\lfloor\sqrt a\rfloor$<ul>
<li>别用：<code>(int) sqrt(a)</code></li>
<li>要用：二分查找 <a target="_blank" rel="noopener" href="https://io.zouht.com/7.html">https://io.zouht.com/7.html</a></li>
</ul>
</li>
<li>$a^b$<ul>
<li>别用：<code>pow(a, b)</code></li>
<li>要用：快速幂 <a target="_blank" rel="noopener" href="https://io.zouht.com/18.html">https://io.zouht.com/18.html</a></li>
</ul>
</li>
<li>$\lfloor\log_2 a\rfloor$<ul>
<li>别用：<code>log2(a)</code></li>
<li>要用：<code>__lg</code> （不规范，但是这是竞赛）&#x2F; <code>bit_width</code>（C++20 可用）</li>
</ul>
</li>
</ul>
<h3 id="gcd-lcm"><a href="#gcd-lcm" class="headerlink" title="gcd() &#x2F; lcm()"></a><code>gcd()</code> &#x2F; <code>lcm()</code></h3><p>（C++17）返回最大公因数 &#x2F; 最小公倍数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-built_in">gcd</span>(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 4</span><br><span class="hljs-type">int</span> y = <span class="hljs-built_in">lcm</span>(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure>

<p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.<br>当然，<code>gcd</code> &#x2F; <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a, b) * b;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/%E5%90%91%E9%87%8F/" class="print-no-link">#向量</a>
      
        <a href="/tags/%E6%A0%88/" class="print-no-link">#栈</a>
      
        <a href="/tags/%E5%A0%86/" class="print-no-link">#堆</a>
      
        <a href="/tags/%E9%9B%86%E5%90%88/" class="print-no-link">#集合</a>
      
        <a href="/tags/%E9%98%9F%E5%88%97/" class="print-no-link">#队列</a>
      
        <a href="/tags/%E6%98%A0%E5%B0%84/" class="print-no-link">#映射</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算竞常用 C++ STL 用法（转载，排版有改动）</div>
      <div>http://example.com/2024/04/26/C++ STL/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ivan Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              IVAN
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/15/git-use/" title="git上传到GitHub">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">git上传到GitHub</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/26/object-oriented-3/" title="面向对象 - 运作逻辑">
                        <span class="hidden-mobile">面向对象 - 运作逻辑</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
