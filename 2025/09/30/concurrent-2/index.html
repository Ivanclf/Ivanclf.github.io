

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/image.jpg">
  <link rel="icon" href="../../../../img/image.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ivan Chan">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java内存模型Java内存模型（JMM）是一套规范，它定义了在多线程环境下，Java程序中变量的访问规则。  共享变量存储在主内存中，每个线程都有一个私有的本地内存，存储了共享变量的副本。  当一个线程更改了本地内存中共享变量的副本，它需要JVM刷新在主内存中的值。 当一个线程需要读取一个共享变量时，如果本地内存中的副本是过期的，它必须从主内存中获取最新的值，并将其存储在本地内存中。  这样操作">
<meta property="og:type" content="article">
<meta property="og:title" content="并发基础 - 2">
<meta property="og:url" content="https://ivanclf.github.io/2025/09/30/concurrent-2/index.html">
<meta property="og:site_name" content="Ivan的博客">
<meta property="og:description" content="Java内存模型Java内存模型（JMM）是一套规范，它定义了在多线程环境下，Java程序中变量的访问规则。  共享变量存储在主内存中，每个线程都有一个私有的本地内存，存储了共享变量的副本。  当一个线程更改了本地内存中共享变量的副本，它需要JVM刷新在主内存中的值。 当一个线程需要读取一个共享变量时，如果本地内存中的副本是过期的，它必须从主内存中获取最新的值，并将其存储在本地内存中。  这样操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ivanclf.github.io/2025/09/30/concurrent-2/jmm1.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/09/30/concurrent-2/monitor.png">
<meta property="og:image" content="https://ivanclf.github.io/2025/09/30/concurrent-2/multilevel1.png">
<meta property="og:image" content="https://ivanclf.github.io/2025/09/30/concurrent-2/atomic.png">
<meta property="og:image" content="https://ivanclf.github.io/2025/09/30/concurrent-2/threadpool1.png">
<meta property="article:published_time" content="2025-09-30T07:06:33.000Z">
<meta property="article:modified_time" content="2025-10-06T17:04:06.076Z">
<meta property="article:author" content="Ivan Chan">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ivanclf.github.io/2025/09/30/concurrent-2/jmm1.jpg">
  
  
  
  <title>并发基础 - 2 - Ivan的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ivanclf.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":30,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Ivan的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/banner-page.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="并发基础 - 2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-30 15:06" pubdate>
          2025年9月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.6k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">并发基础 - 2</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型（JMM）是一套规范，它定义了在多线程环境下，Java程序中变量的访问规则。</p>
<p><img src="jmm1.jpg" srcset="/img/loading.gif" lazyload alt="Java内存模型"></p>
<p>共享变量存储在主内存中，每个线程都有一个私有的本地内存，存储了共享变量的副本。</p>
<ul>
<li>当一个线程更改了本地内存中共享变量的副本，它需要JVM刷新在主内存中的值。</li>
<li>当一个线程需要读取一个共享变量时，如果本地内存中的副本是<strong>过期</strong>的，它必须从主内存中获取最新的值，并将其存储在本地内存中。</li>
</ul>
<p>这样操作可以减少CPU访问RAM的开销。</p>
<p>JMM主要关注以下几个方面：</p>
<ol>
<li><strong>原子性</strong><br> 一个或多个操作，要么全部成功，要么全部不执行。保证操作的不可分割性。JMM保证了基本数据类型的读写操作的原子性，但对于复合操作（如i++）则不保证原子性。</li>
<li><strong>可见性</strong><br> 确保一个线程对共享变量的修改，其他线程能够立即看到。</li>
<li><strong>有序性</strong><br> 保证程序执行的顺序符合代码的书写顺序。一般情况下，CPU或编译器会对指令进行重排序优化。从Java源代码到最终的指令序列，会经历3种重排序：编译器重排序、指令并行重排序、内存系统重排序。指令重排可能会导致双重检查锁失效。</li>
</ol>
<h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><p>JMM规定了<code>Happens-Before</code>原则，用于定义操作之间的可见性关系。常见的<code>Happens-Before</code>规则包括：</p>
<ul>
<li>程序顺序规则：一个线程内，按代码顺序执行，前面的操作先于后面的操作。</li>
<li>监视器锁规则：一个解锁操作先于后续对同一锁的加锁操作。<br>  <code>unlock() happens-before lock()</code></li>
<li><code>volatile</code>变量规则：对一个<code>volatile</code>变量的写操作先于后续对该变量的读操作。<br>  <code>write to v happens-before read of v</code></li>
<li>传递性：如果操作A先于操作B，操作B先于操作C，那么操作A先于操作C。<br>  <code>A happens-before B</code> and <code>B happens-before C</code> implies <code>A happens-before C</code></li>
<li>线程启动规则：<code>Thread.start()</code>方法先于被启动线程的任何操作。<br>  <code>Thread.start() happens-before any action in the started thread</code></li>
<li>线程终止规则：线程的所有操作先于其他线程检测到该线程终止的动作（如<code>Thread.join()</code>返回）。<br>  <code>All actions in a thread happen-before any other thread detects that thread has terminated</code></li>
</ul>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>JMM允许编译器和处理器对代码进行优化和重排序，但必须保证单线程程序的执行结果与未优化的程序一致。这种优化称为<code>as-if-serial</code>语义。</p>
<p>比如在这行语句下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;   <span class="hljs-comment">// A</span><br><span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;   <span class="hljs-comment">// B</span><br><span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> pi * r * r;   <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure>

<p>语句间的依赖关系如下</p>
<pre><code class=" mermaid">graph TD
    A((A)) --&gt; C((C))
    B((B)) --&gt; C
</code></pre>

<p>因此<code>C</code>必须在<code>A</code>和<code>B</code>之后执行，但<code>A</code>和<code>B</code>之间没有依赖关系，可以交换顺序执行。</p>
<p><code>Happens-Before</code> 规则保证了多线程环境下的有序性，防止指令重排导致的并发问题。<code>As-If-Serial</code> 规则保证了单线程代码不会因优化而执行错误。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><code>volatile</code>关键字</h2><p>在加了这个关键字后，可以保证该变量的可见性，线程修改该变量后，其他线程能够立即看到最新值；同时，防止指令重排，其写操作不会被重排到它以前的代码。</p>
<p>为了保证可见性，线程对<code>volatile</code>变量进行写操作时，会在该变量写入后插入一个写屏障（<strong>StoreStore + StoreLoad</strong>屏障）指令，该指令会强制将本地内存中的变量值刷新到主内存中。在<code>x86</code>中，通常会使用带<code>lock</code>前缀的指令实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov [a], 2<br>lock add [a], 0<br></code></pre></td></tr></table></figure>

<p>进行读操作时，JVM会插入一个读屏障（<strong>LoadLoad + LoadStore</strong>屏障）指令，强制从主内存中读取最新值到本地内存</p>
<p>总之，该关键字变量在读写前后插入内存屏障，以约束CPU和编译器的优化行为</p>
<ul>
<li><code>StoreStore</code>屏障：保证该屏障前的写操作必须在该屏障后的写操作之前完成</li>
<li><code>StoreLoad</code>屏障：保证该屏障前的写操作必须在该屏障后的读操作之前完成</li>
<li><code>LoadLoad</code>屏障：保证该屏障前的读操作必须在该屏障后的读操作之前完成</li>
<li><code>LoadStore</code>屏障：保证该屏障前的读操作必须在该屏障后的写操作之前完成</li>
</ul>
<p><code>volatile</code>关键字用于基本数据类型时，能确保变量的读写操作是直接从主内存中读写的，用于引用类型时，能确保引用本身的可见性，即确保引用指向的对象地址是最新的，但不能保证引用对象的内部状态的可见性。若需要保证引用对象的内部状态的可见性，需对该对象的字段也使用<code>volatile</code>关键字，或者使用其他同步机制（如<code>synchronized</code>块或<code>ReentrantLock</code>）来确保线程安全。</p>
<h2 id="synchronized关键字与ReentrantLock"><a href="#synchronized关键字与ReentrantLock" class="headerlink" title="synchronized关键字与ReentrantLock"></a><code>synchronized</code>关键字与<code>ReentrantLock</code></h2><p><code>synchronized</code>关键字用于方法或代码块，确保同一时刻只有一个线程可以执行该代码，从而保证线程安全。它通过对象的监视器锁（Monitor Lock）实现。</p>
<p>在对代码块进行加锁时，JVM会在进入代码块前调用<code>monitorenter</code>指令获取锁，执行完代码块后调用<code>monitorexit</code>指令释放锁。如果一个线程尝试获取一个已经被其他线程持有的锁，它将被阻塞，直到锁被释放。</p>
<p><code>Monitor</code>是JVM内置的同步机制，每个对象在内存中都有一个对象头——Mark Word，用于存储锁的状态，以及<code>Monitor</code>对象的指针。</p>
<p><img src="monitor.png" srcset="/img/loading.gif" lazyload alt="Java对象头"></p>
<p><code>synchronized</code> 依赖对象头的 Mark Word 进行状态管理，支持无锁、偏向锁、轻量级锁，以及重量级锁。</p>
<p><code>synchronized</code> 升级为重量级锁时，依赖于操作系统的互斥量——<code>mutex</code> 来实现。</p>
<p>为了保证可见性，<code>synchronized</code>块在释放锁时会将本地内存中的变量值刷新到主内存中，在获取锁时会从主内存中读取最新值到本地内存。</p>
<p>为了保证有序性，该关键字通过 JVM 指令 <code>monitorenter</code> 和 <code>monitorexit</code>，来确保加锁代码块内的指令不会被重排。</p>
<p>可重入意味着一个线程可以多次获取同一把锁，而不会导致死锁。</p>
<div class="note note-info">
            <p><code>synchronized</code> 之所以支持可重入，是因为 Java 的对象头包含了一个 Mark Word，用于存储对象的状态，包括锁信息。</p><p>当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。</p><p>如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。</p><p>当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。</p>
          </div>

<p>Java中多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁。更精确地说，<code>synchronized</code>锁定的是对象的监视器（Monitor），而不是对象本身。</p>
<div class="note note-info">
            <ul><li>在同步实例方法时，锁的是当前实例对象<code>this</code></li><li>在同步静态方法时，锁的是类的<code>Class</code>对象</li><li>在同步代码块时，锁的是括号中指定的对象</li></ul><p>无论哪种方式，线程在进入<code>synchronized</code>块之前，都必须先成功获取指定休想的监视器锁，否则线程将被阻塞，直到锁可用为止。</p>
          </div>

<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>在JDK 1.6 之前，<code>synchronized</code>使用的是重量级锁，性能较差。JDK 1.6 引入了锁升级机制，包括<strong>偏向锁</strong>、<strong>轻量级锁</strong>和<strong>重量级锁</strong>，以提高性能。这几种锁会随着竞争情况逐渐升级。锁的升级很简单，但发生的条件就很苛刻了。</p>
<p>在没有线程竞争时，就使用低开销的“偏向锁”，此时没有额外的CAS操作。当有轻微竞争时，升级为“轻量级锁”，采用CAS自旋。当竞争激烈时，升级为“重量级锁”，需要进行线程阻塞。</p>
<p>锁有四种状态。</p>
<ul>
<li>无锁状态（Unlocked）：对象处于无锁状态，Mark Word 存储对象的哈希码等信息。</li>
<li>偏向锁状态（Biased Locking）：当一个线程访问同步块时，JVM 会将该线程的 ID 写入 Mark Word，并将锁标记为偏向锁状态。后续该线程再次访问该同步块时，无需进行任何同步操作，直接进入同步块，避免了不必要的锁操作开销。</li>
<li>轻量级锁状态（Lightweight Locking）：当另一个线程尝试获取已经被偏向锁持有的锁时，JVM 会将偏向锁升级为轻量级锁。JVM 会创建一个锁记录（Lock Record）并将其压入当前线程的栈帧中，同时使用CAS操作将对象的Mark Word替换为指向锁记录的指针。线程在进入同步块时，会尝试通过自旋来获取锁。当自选了一定次数后，仍然没有获取锁，说明竞争比较激烈，JVM 会将轻量级锁升级为重量级锁。</li>
<li>重量级锁状态（Heavyweight Locking）：当多个线程竞争同一把锁时，轻量级锁会升级为重量级锁。JVM 会创建一个互斥量（Mutex）对象，并将对象的Mark Word替换为指向该互斥量的指针。线程在获取锁时，如果锁已被其他线程持有，它将被阻塞，直到锁可用为止。</li>
</ul>
<p><img src="multilevel1.png" srcset="/img/loading.gif" lazyload alt="自旋和阻塞的区别"></p>
<h3 id="与ReentrantLock对比"><a href="#与ReentrantLock对比" class="headerlink" title="与ReentrantLock对比"></a>与<code>ReentrantLock</code>对比</h3><p>两句话回答：<code>synchronized</code>由JVM内部的<code>Monitor</code>实现，<code>ReentrantLock</code>基于AQS实现。</p>
<p>因此前者可以自动加锁和解锁，而后者需要手动加锁和解锁。</p>
<div class="note note-info">
            <p>什么是AQS？它是一个抽象类，维护了一个<code>volatile</code>类型的<code>int</code>变量<code>state</code>（保证多线程之间的可见性），表示锁的状态。AQS通过一个FIFO双向队列来管理获取锁失败的线程。</p><p>AQS支持两种同步模式：</p><ul><li>独占模式（Exclusive Mode）：一次只有一个线程可以获取锁，其他线程必须等待。<code>ReentrantLock</code>就是基于AQS的独占模式实现的。</li><li>共享模式（Shared Mode）：允许多个线程同时获取锁。<code>Semaphore</code>和<code>CountDownLatch</code>是基于AQS的共享模式实现的。</li></ul><p>核心方法包括</p><ul><li><code>acquire(int arg)</code>：尝试获取锁，如果失败则将当前线程加入等待队列并阻塞。</li><li><code>release(int arg)</code>：释放锁，并唤醒等待队列中的下一个线程。</li><li><code>acquireShared(int arg)</code>：尝试以共享模式获取锁。</li><li><code>releaseShared(int arg)</code>：以共享模式释放锁。</li></ul><p>维护的队列称为CLH队列。在CLH中，当一个线程尝试获取锁失败后，会被添加到队尾并自旋，等待前驱节点释放锁。</p>
          </div>

<h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a><code>ReentrantLock</code>的实现原理</h3><p><code>ReentrantLock</code>内部通过一个计数器 <code>state</code> 来跟踪锁的状态和持有次数。当线程调用 <code>lock()</code> 方法获取锁时，<code>ReentrantLock</code> 会检查 <code>state</code> 的值，如果为 0，通过CAS修改为 1，表示成功加锁。否则根据当前线程的公平性策略，加入到等待队列中。</p>
<p>线程首次获取锁时，<code>state</code> 值设为 1；如果同一个线程再次获取锁时，<code>state</code> 加 1；每释放一次锁，<code>state</code> 减 1。</p>
<p>当线程调用 <code>unlock()</code> 方法时，<code>ReentrantLock</code> 会将持有锁的 <code>state</code> 减 1，如果 <code>state = 0</code>，则释放锁，并唤醒等待队列中的线程来竞争锁。</p>
<p><code>ReentrantLock</code>默认为非公平锁，若在创建的时候传入<code>true</code>，则为公平锁。</p>
<div class="note note-info">
            <p>公平锁严格按照先进先得原则，严格按照线程请求锁的顺序来分配锁；非公平锁允许插队，谁先抢到就是谁的。</p>
          </div>

<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p><img src="atomic.png" srcset="/img/loading.gif" lazyload alt="原子操作类"></p>
<p>原子操作类是基于<code>CAS + volatile</code>实现的。底层基于<code>Unsafe</code>类的<code>compareAndSwapXXX</code>方法实现。</p>
<p>像 <code>AtomicIntegerArray</code> 这种以 Array 结尾的，还可以原子更新数组里的元素；像 <code>AtomicStampedReference</code> 还可以通过版本号的方式解决 CAS 中的 ABA 问题。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的问题在<a href="https://ivanclf.github.io/2025/05/14/os/">另一篇文章</a>中有所提及，此处仅涉及其中的部分问题</p>
<h3 id="死锁的排查"><a href="#死锁的排查" class="headerlink" title="死锁的排查"></a>死锁的排查</h3><p>首先可以在系统级别上排查，比如在Linux中，可以先使用<code>top ps</code>等命令查看线程状态，看看是否有线程占用过多资源。</p>
<p>接着，使用<code>jps -l</code>查看当前进程，然后使用<code>jstack &lt;pid&gt;</code>查看线程堆栈，若有线程处于<code>BLOCKED</code>状态，则说明该线程在等待锁。</p>
<p>也可以使用一些可视化的性能监控工具，比如说 <code>JConsole</code>、<code>VisualVM</code> 等，查看线程的运行状态、锁的竞争情况等。</p>
<div class="note note-info">
            <p>尽管在另一篇文章中，讲述了很多死锁的解决方案，但最常用的还是给锁加超时时间，避免线程长时间等待锁。这也是在<a href="https://ivanclf.github.io/2025/09/24/redis-2/">这篇文章</a>中即使用看门狗机制延长时间也不取消锁过期时间的原因。</p>
          </div>

<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><p>同步，意味着线程直接要密切合作，按照一定的顺序执行任务。互斥，意味着线程之间要避免同时访问某些资源。同步关注的是线程直接的协作，互斥关注的是对共享资源的保护。</p>
<p>为了实现同步，可以使用<code>CountDownLatch</code>、<code>CyclicBarrier</code>等工具类，或者使用<code>wait()</code>和<code>notify()</code>方法来协调线程之间的执行顺序。<br>为了实现互斥，可以使用<code>synchronized</code>关键字、<code>ReentrantLock</code>类等来确保同一时刻只有一个线程可以访问某个资源。</p>
<p>可以使用<code>synchronized</code>关键字或者<code>lock</code>接口的实现类，如<code>ReentrantLock</code>，来给资源加锁。</p>
<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 是 JUC 中的一个同步工具类，用于协调多个线程之间的同步，确保主线程在多个子线程完成任务后继续执行。它的核心思想是通过一个倒计时计数器来控制多个线程的执行顺序。</p>
<p>假如要查10万多条数据，用线程池分成20个线程去执行，怎么做到等所有线程都查找完后，才输出结果？这就是<code>CountDownLatch</code>的典型应用场景。</p>
<ol>
<li>创建 <code>CountDownLatch</code> 对象，初始值设定为 20，表示 20 个线程需要完成任务。</li>
<li>创建线程池，每个线程执行查询操作，查询完毕后调用 <code>countDown()</code> 方法，计数器减 1。</li>
<li>主线程调用 <code>await()</code> 方法，等待所有线程执行完毕。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataQueryExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 模拟10万条数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalRecords</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> totalRecords / threadCount; <span class="hljs-comment">// 每个线程处理的数据量</span><br><br>        <span class="hljs-comment">// 创建线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadCount);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadCount);<br><br>        <span class="hljs-comment">// 模拟查询结果</span><br>        ConcurrentLinkedQueue&lt;String&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i * batchSize; <span class="hljs-comment">// 起始索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> (i == threadCount - <span class="hljs-number">1</span>) ? totalRecords : (start + batchSize); <span class="hljs-comment">// 结束索引</span><br>            <br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 模拟查询操作</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> start; j &lt; end; j++) &#123;<br>                        results.add(<span class="hljs-string">&quot;Data-&quot;</span> + j);<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 处理数据 &quot;</span> + start + <span class="hljs-string">&quot; - &quot;</span> + end);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch.countDown(); <span class="hljs-comment">// 线程任务完成，计数器减1</span><br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程完成</span><br>        latch.await();<br>        executor.shutdown();<br><br>        <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;所有线程执行完毕，查询结果总数：&quot;</span> + results.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 的字面意思是可循环使用的屏障，用于多个线程相互等待，直到所有线程都到达屏障后再同时执行。在使用的时候，我们需要先初始化一个 <code>CyclicBarrier</code> 对象，指定一个屏障值 N，表示需要等待的线程数量。然后每个线程执行 <code>await()</code> 方法，表示自己已经到达屏障，等待其他线程，此时屏障值会减 1。当所有线程都到达屏障后，也就是屏障值为 0 时，所有线程会继续执行。</p>
<p><code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别如下表</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th><code>CountDownLatch</code></th>
<th><code>CyclicBarrier</code></th>
</tr>
</thead>
<tbody><tr>
<td>用途</td>
<td>让主线程等待所有子线程执行完</td>
<td>多个线程相互等待，直到所有线程都到达屏障</td>
</tr>
<tr>
<td>可重用性</td>
<td>不可重用，计数器只能减到0</td>
<td>可重用，屏障值可以重新设置</td>
</tr>
<tr>
<td>是否可执行回调</td>
<td>不可以</td>
<td>可以，所有线程到达屏障后可执行<code>barrierAction</code></td>
</tr>
<tr>
<td>线程等待情况</td>
<td>主线程等待子线程</td>
<td>所有线程相互等待</td>
</tr>
<tr>
<td>适用场景</td>
<td>主线程等待子线程完成</td>
<td>线程相互依赖</td>
</tr>
<tr>
<td>示例场景</td>
<td>等待多个服务启动完成</td>
<td>多线程计算，最后汇总结果</td>
</tr>
</tbody></table>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">推荐阅读</a></p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>线程池是用来管理和复用线程的工具，可以提高系统的性能和资源利用率。Java 中线程池的核心实现为<code>ThreadPoolExecutor</code>，并提供了 <code>Executor</code> 框架来简化线程池的创建和管理。</p>
<p>在创建线程时可以显式指定线程组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(ThreadGroup group, Runnable target)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(ThreadGroup group, String name)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(ThreadGroup group, Runnable target, String name)</span>;<br></code></pre></td></tr></table></figure>

<p>其工作流程如下</p>
<ol>
<li>线程池通过<code>submit()</code>或<code>execute()</code>方法接收任务。</li>
<li>线程池首先检查核心线程数是否已满，若未满则创建新线程执行任务。</li>
<li>若核心线程数已满，则将任务放入任务队列中。</li>
<li>若任务队列已满且线程数未达最大值，则创建新线程执行任务。</li>
<li>若任务队列已满且线程数已达最大值，则根据拒绝策略处理任务。</li>
<li>线程执行完任务后，若线程数超过核心线程数且空闲时间超过<code>keepAliveTime</code>，则终止该线程</li>
</ol>
<pre><code class=" mermaid">graph TD
    A[execute或submit] --&gt; B&#123;核心线程数未满?&#125;
    
    B --&gt;|是| C[创建新线程执行任务]
    B --&gt;|否| D&#123;任务队列未满?&#125;
    
    D --&gt;|是| E[将任务放入任务队列]
    D --&gt;|否| F&#123;最大线程数未满?&#125;
    
    F --&gt;|是| G[创建新线程执行任务]
    F --&gt;|否| H[执行拒绝策略]
</code></pre>

<p>线程池的主要参数如下</p>
<ul>
<li><code>corePoolSize</code>：核心线程数，线程池中始终保持的线程数量。</li>
<li><code>maximumPoolSize</code>：最大线程数，线程池中允许的最大线程数量</li>
<li><code>keepAliveTime</code>：线程空闲时间，超过该时间的非核心线程将被终止。</li>
<li><code>unit</code>：时间单位，<code>keepAliveTime</code>的时间单位。</li>
<li><code>workQueue</code>：任务队列，用于存储等待执行的任务。</li>
<li><code>threadFactory</code>：线程工厂，用于创建新线程。</li>
<li><code>handler</code>：拒绝策略，当任务无法执行时的处理方式。</li>
</ul>
<p>线程池的提交有两种方式：<code>execute()</code>和<code>submit()</code>。前者用于提交不需要返回值的任务，后者用于提交需要返回值的任务，返回一个<code>Future</code>对象。</p>
<p>其拒绝策略有4种</p>
<ul>
<li><code>AbortPolicy</code>：默认策略，抛出<code>RejectedExecutionException</code>异常。</li>
<li><code>CallerRunsPolicy</code>：调用者运行策略，任务由调用者线程执行。</li>
<li><code>DiscardPolicy</code>：丢弃策略，直接丢弃任务，不抛出异常。</li>
<li><code>DiscardOldestPolicy</code>：丢弃最旧任务策略，丢弃任务队列中最旧的任务，然后尝试执行当前任务。</li>
</ul>
<p>线程池的关闭有两种方式，分别是<code>shutdown()</code>和<code>shutdownNow()</code>。前者会等待所有任务执行完毕后关闭线程池，后者会立即关闭线程池，并尝试停止所有正在执行的任务，停止的方式包括停止接收外部提交的任务、忽略任务队列中未执行的任务、尝试给正在跑的任务大宋<code>interrupt()</code>中断信号。</p>
<div class="note note-info">
            <p>线程数安排多少个比较合适呢？一般需要分析线程池执行的任务类型是CPU密集型还是IO密集型。</p><ul><li>对于CPU密集型任务，线程数一般设置为CPU核心数加1。<br>  我们的目标是尽量减少线程的上下文切换，以优化CPU使用率，而+1是以备不时之需。若某线程因等待系统资源而阻塞，其他线程可以继续执行。</li><li>对于IO密集型任务，线程数可以设置为CPU核心数的2到3倍，甚至更多。<br><img src="threadpool1.png" srcset="/img/loading.gif" lazyload alt="由上面的推荐阅读中获取的常见线程池参数配置方案"></li></ul><p>而其他参数则按照业务具体需求来。</p><p>若CPU使用率较低，可能是线程数过少；若CPU使用率较高但吞吐量不高，可能是线程数过多。</p>
          </div>

<h3 id="常见的线程池"><a href="#常见的线程池" class="headerlink" title="常见的线程池"></a>常见的线程池</h3><p>常见的线程池有4种</p>
<ul>
<li><code>FixedThreadPool</code>：固定大小线程池，适用于任务量较大且任务执行时间较长的场景。如IO密集型任务、数据库连接池等。<br>  其线程池大小是固定的，默认使用<code>LinkedBlockingQueue</code>作为任务队列，拒绝策略为<code>AbortPolicy</code>。其缺点是任务队列默认无界，可能会导致内存溢出（或者说会导致<code>OOM</code>，<code>OutOfMemoryError</code>）。</li>
<li><code>CachedThreadPool</code>：可缓存线程池，适用于任务量较大且任务执行时间较短的场景。如短时间内大量的文件处理或网络请求等。<br>  其线程池大小不固定。空闲线程超过60秒会被终止，默认使用<code>SynchronousQueue</code>作为任务队列，拒绝策略为<code>AbortPolicy</code>。其优点是线程池可以根据任务量动态调整大小，缺点是线程数没有上限，可能会创建大量线程，导致系统资源耗尽。</li>
<li><code>SingleThreadExecutor</code>：单线程线程池，适用于需要顺序执行任务的场景。如日志处理、定时任务等。<br>  线程池只有一个线程，保证任务按顺序执行，默认使用<code>LinkedBlockingQueue</code>作为任务队列，拒绝策略为<code>AbortPolicy</code>。其缺点是单线程可能成为性能瓶颈。</li>
<li><code>ScheduledThreadPool</code>：定时任务线程池，适用于需要定时或周期性执行任务的场景。如定时数据备份、定时清理缓存等。<br>  线程池大小可配置，支持定时或周期性任务执行。默认使用<code>DelayedWorkQueue</code>作为任务队列，拒绝策略为<code>AbortPolicy</code>。其优点是支持定时和周期性任务，缺点是线程数没有上限，可能会创建大量线程，导致系统资源耗尽。</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>线程池的异常处理常见有四种方式</p>
<ol>
<li>最简单的，<code>try-catch</code>处理。</li>
<li>使用<code>Future</code>对象的<code>get()</code>方法获取异常。<br> 建议使用<code>submit()</code>的项目使用这种方式。</li>
<li>自定义线程池，重写<code>afterExecute()</code>方法处理异常。<br> 建议想要全局处理异常的项目使用这种方式。</li>
<li>使用<code>UncaughtExceptionHandler</code>处理未捕获异常。<br> 建议使用<code>execute()</code>的项目使用这种方式。</li>
</ol>
<p>线程池有5种状态，并且它们之间严格按照状态流转规则流转。</p>
<pre><code class=" mermaid">graph TD
    A[RUNNING] --&gt; |shutdown|B[SHUTDOWN]
    A--&gt;|shutdownNow|C[STOP]
    B --&gt; |队列为空且工作线程数为0|D[TIDYING]
    C --&gt; |工作线程数为0|D
    D --&gt; |terminated|E[TERMINATED]
</code></pre>

<p><code>RUNNING</code> 状态的线程池可以接收新任务，并处理阻塞队列中的任务；<code>SHUTDOWN</code> 状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<code>STOP</code> 状态的线程池不会接收新任务，也不会处理阻塞队列中的任务，并且会尝试中断正在执行的任务；<code>TIDYING</code> 状态表示所有任务已经终止；<code>TERMINATED</code> 状态表示线程池完全关闭，所有线程销毁。</p>
<p>使用线程池提供的<code>setter()</code>方法就可以修改线程池的参数。</p>
<p>需要注意的是，调用 <code>setCorePoolSize()</code> 时如果新的核心线程数比原来的大，线程池会创建新的线程；如果更小，线程池不会立即销毁多余的线程，除非有空闲线程超过 <code>keepAliveTime</code>。<br>当然了，还可以利用 <code>Nacos</code> 配置中心，或者实现自定义的线程池，监听参数变化去动态调整参数。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>实现线程池调优：</p>
<ul>
<li>根据任务类型设置核心线程数参数，比如 IO 密集型任务会设置为 CPU 核心数*2 的经验值。</li>
<li>结合线程池动态调整的能力，在流量波动时通过 <code>setCorePoolSize</code> 平滑扩容，或者直接使用 <code>DynamicTp</code> 实现线程池参数的自动化调整。</li>
<li>通过内置的监控指标建立容量预警机制。比如通过 JMX 监控线程池的运行状态，设置阈值，当线程池的任务队列长度超过阈值时，触发告警。</li>
</ul>
<p>线程池是在内存里运行的，断电后相关信息也会丢失。为了防止丢失，可以将线程池的状态信息持久化到数据库或文件中，定期备份。或者配置一个恢复流程。</p>
<p>下面是一个手搓的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleThreadPool</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Thread[] workers;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> isShutdown;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.isShutdown = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 初始化工作线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            workers[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;Worker-&quot;</span> + i);<br>            workers[i].start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isShutdown) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;ThreadPool is shutdown&quot;</span>);<br>        &#125;<br>        taskQueue.offer(task);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        isShutdown = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (Thread worker : workers) &#123;<br>            worker.interrupt(); <span class="hljs-comment">// 中断等待中的线程</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!isShutdown || !taskQueue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskQueue.take(); <span class="hljs-comment">// 阻塞获取任务</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-comment">// 响应中断，重新检查关闭状态</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用示例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SimpleThreadPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleThreadPool</span>(<span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 提交10个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            pool.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() <br>                    + <span class="hljs-string">&quot; executing task &quot;</span> + taskId);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 关闭线程池</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            pool.shutdown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以下是一个数据库链接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleConnectionPool</span> &#123;<br>    <span class="hljs-comment">// 配置</span><br>    <span class="hljs-keyword">private</span> String jdbcUrl;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxConnections;<br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Connection&gt; connectionPool;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleConnectionPool</span><span class="hljs-params">(String jdbcUrl, String username, String password, <span class="hljs-type">int</span> maxConnections)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-built_in">this</span>.jdbcUrl = jdbcUrl;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.maxConnections = maxConnections;<br>        <span class="hljs-built_in">this</span>.connectionPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(maxConnections);<br><br>        <span class="hljs-comment">// 初始化连接池</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxConnections; i++) &#123;<br>            connectionPool.add(createNewConnection());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建新连接</span><br>    <span class="hljs-keyword">private</span> Connection <span class="hljs-title function_">createNewConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(jdbcUrl, username, password);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionPool.poll(timeout, unit); <span class="hljs-comment">// 等待指定时间获取连接</span><br>        <span class="hljs-keyword">if</span> (connection == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">&quot;Timeout: Unable to acquire a connection.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br><br>    <span class="hljs-comment">// 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseConnection</span><span class="hljs-params">(Connection connection)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (connection.isClosed()) &#123;<br>                <span class="hljs-comment">// 如果连接已关闭，创建一个新连接补充到池中</span><br>                connectionPool.add(createNewConnection());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 将连接归还到池中</span><br>                connectionPool.offer(connection);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭所有连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeAllConnections</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">for</span> (Connection connection : connectionPool) &#123;<br>            <span class="hljs-keyword">if</span> (!connection.isClosed()) &#123;<br>                connection.close();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试用例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SimpleConnectionPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleConnectionPool</span>(<br>                <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/pai_coding&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">5</span><br>            );<br><br>            <span class="hljs-comment">// 获取连接</span><br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> pool.getConnection(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br>            <span class="hljs-comment">// 使用连接（示例查询）</span><br>            System.out.println(<span class="hljs-string">&quot;Connection acquired: &quot;</span> + conn);<br>            Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟查询</span><br><br>            <span class="hljs-comment">// 归还连接</span><br>            pool.releaseConnection(conn);<br>            System.out.println(<span class="hljs-string">&quot;Connection returned.&quot;</span>);<br><br>            <span class="hljs-comment">// 关闭所有连接</span><br>            pool.closeAllConnections();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/web/" class="category-chain-item">web</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/java/" class="print-no-link">#java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>并发基础 - 2</div>
      <div>https://ivanclf.github.io/2025/09/30/concurrent-2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ivan Chan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="../../../10/06/jvm/" title="JVM的底层实现">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM的底层实现</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../29/concurrent/" title="并发基础 - 1">
                        <span class="hidden-mobile">并发基础 - 1</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default","securityLevel":"loose"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
