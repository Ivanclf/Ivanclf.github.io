

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/image.jpg">
  <link rel="icon" href="../../../../img/image.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ivan Chan">
  <meta name="keywords" content="">
  
    <meta name="description" content="二叉树二叉树中序遍历无需多言 1234567891011class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();        if(root &#x3D;&#x3D; null">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode热题100官方题解 - 3">
<meta property="og:url" content="https://ivanclf.github.io/2025/08/13/leetcode-3/index.html">
<meta property="og:site_name" content="Ivan的博客">
<meta property="og:description" content="二叉树二叉树中序遍历无需多言 1234567891011class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();        if(root &#x3D;&#x3D; null">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/invert1-tree.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/1698026966-JDYPDU-image.png">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/diamtree.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/explain1.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/btree1.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/kthtree1.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/tmpd5jn43fs-1.png">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/flaten.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/tree.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/pathsum3-1-tree.jpg">
<meta property="og:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/leetcode-3/binarytree.png">
<meta property="article:published_time" content="2025-08-13T07:36:00.000Z">
<meta property="article:modified_time" content="2025-08-25T09:21:11.787Z">
<meta property="article:author" content="Ivan Chan">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ivanclf.github.io/2025/08/13/leetcode-3/invert1-tree.jpg">
  
  
  
  <title>leetcode热题100官方题解 - 3 - Ivan的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ivanclf.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":30,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Ivan的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/banner-page.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="leetcode热题100官方题解 - 3"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-13 15:36" pubdate>
          2025年8月13日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">leetcode热题100官方题解 - 3</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h4><p>无需多言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        list.addAll(inorderTraversal(root.left));<br>        list.add(root.val);<br>        list.addAll(inorderTraversal(root.right));<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>接下来提供迭代做法。由于递归实质上也是在维护一个栈（拿内存当栈用），因此迭代可以将这个栈显示出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        Deque&lt;TreeNode&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stk.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stk.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stk.pop();<br>            res.add(root.val);<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>存储一个栈。栈每次固定弹出一个。在此题中，放入的条件为先放入左子树，读取栈数据，再放入其右子树。</p>
          </div>

<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>也无需多言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> root == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : Math.max(maxDepth(root.left) + <span class="hljs-number">1</span>, maxDepth(root.right) + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>递归更多是使用dfs的思想，也可以使用bfs来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        queue.offer(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>                    queue.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>                    queue.offer(node.right);<br>                size--;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用bfs时，队列里存放的是当前层的所有节点，每次拓展下一层时，bfs算法每次从队列中拿出一个节点并遍历出其左右节点。而在此题中需要把队列中的所有节点都拿来拓展</p>
          </div>

<h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。<br><img src="invert1-tree.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：root &#x3D; [4,2,7,1,3,6,9]<br>    输出：[4,7,2,9,6,3,1]</p>
<p>无需多言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>        root.left = invertTree(root.right);<br>        root.right = temp;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p>只要能用递归的二叉树都不算难，并且递归都能用队列迭代来替代实现。</p>
          </div>

<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p>示例：<br><img src="1698026966-JDYPDU-image.png" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>root = [1,2,2,3,4,4,3]</code><br>    输出：<code>true</code></p>
<p>依然可以使用递归。难点在于互为镜像的条件。本题中镜像条件如下</p>
<ul>
<li>对应的两个根结点具有相同的值</li>
<li>每个右子树都与另一个左子树镜像对称</li>
</ul>
<p>因此可以实现这样一个递归函数，通过“同步移动”两个指针的方法来遍历这棵树。当一个左移时另一个右移，反之亦然。每次检查两个值是否相等，若相等再判断两个子树是否对称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> check(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>使用迭代时，需要把根节点入队两个并提取两个节点，最后比较他们的值。然后将两个节点的左右子节点按相反的顺序插入队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode u, TreeNode v)</span> &#123;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        q.offer(u);<br>        q.offer(v);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            u = q.poll();<br>            v = q.poll();<br>            <span class="hljs-keyword">if</span> (u == <span class="hljs-literal">null</span> &amp;&amp; v == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((u == <span class="hljs-literal">null</span> || v == <span class="hljs-literal">null</span>) || (u.val != v.val))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            q.offer(u.left);<br>            q.offer(v.right);<br><br>            q.offer(u.right);<br>            q.offer(v.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<h4 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h4><p>给你一棵二叉树的根节点，返回该树的直径 。<br>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。<br>两节点之间路径的长度由它们之间边数表示。</p>
<p>示例：<br><img src="diamtree.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>root = [1,2,3,4,5]</code><br>    输出：<code>3</code><br>    解释：<code>3</code> ，取路径 <code>[4,2,1,3]</code> 或 <code>[5,2,1,3]</code> 的长度。</p>
<p>任意一条路径的长度为该路径经过的节点数减一，而任一路径均可以看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p>
<p><img src="explain1.jpg" srcset="/img/loading.gif" lazyload alt="路径 [9, 4, 2, 5, 7, 8] 可以被看作以 2 为起点，从其左儿子向下遍历的路径 [2, 4, 9] 和从其右儿向下遍历的路径 [2, 5, 7, 8] 拼接得到。"></p>
<p>于是，某节点为起点的路径纪念馆过节点数的最大值为$L+R+1$。而二叉树直径就是所有结点路径的最大值减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ans = <span class="hljs-number">1</span>;<br>        depth(root);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">depth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> depth(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> depth(node.right);<br>        ans = Math.max(ans, L+R+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(L, R) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中的<code>ans</code>为路径的最大值。</p>
<h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><p>参考<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">求最大高度的迭代代码</a>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>          ArrayList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            temp.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)<br>              queue.offer(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)<br>              queue.offer(node.right);<br>            size--;<br>          &#125;<br>          ans.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>平衡</strong> 二叉搜索树。</p>
<p>示例：<br><img src="btree1.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>nums = [-10,-3,0,5,9]</code><br>    输出：<code>[0,-3,9,-10,null,5]</code><br>    解释：<code>[0,-10,5,null,-3,null,9]</code> 也将被视为正确答案</p>
<div class="note note-info">
            <p>平衡二叉树的子树也一定是平衡二叉树，因此可以通过子数列递归实现。就我的通过代码来看，时间最快但空间使用率吓人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length, middle = length / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[middle]);<br>        <span class="hljs-keyword">if</span>(middle != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, middle);<br>            ans.left = sortedArrayToBST(left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(middle != length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(nums, middle + <span class="hljs-number">1</span>, length);<br>            ans.right = sortedArrayToBST(right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<p>按照题解，选择中间靠左、中间靠右、任意数作为根节点都有对应的BST，此处仅选择第一种。此时的根节点下标为（整数除法）<br>$$<br>\text{mid}&#x3D;\frac{\text{left+right}}{2}<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = helper(nums, left, mid - <span class="hljs-number">1</span>);<br>        root.right = helper(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。<br>示例略</p>
<div class="note note-info">
            <p>观察到BST的中序遍历是升序排列，因此只要比较中序遍历出来的数组是否满足升序排列就行。但该方法还不是最快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">history</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, now;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            now = root.val;<br>            <span class="hljs-keyword">if</span>(history != <span class="hljs-literal">null</span> &amp;&amp; now &lt;= history)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            history = now;<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<p>依然可以使用递归来做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> root.left.val &lt; root.val &amp;&amp; isValidBST(root.left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> root.right.val &gt; root.val &amp;&amp; isValidBST(root.right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> root.left.val &lt; root.val &amp;&amp; root.right.val &gt; root.val &amp;&amp; isValidBST(root.left) &amp;&amp; isValidBST(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>我写的递归和这个递归的思路是一致的：BST的子树也会是BST。但是我的会因为这种情况而判错</p><pre><code class=" mermaid">graph TD
5--&gt;4
5--&gt;6--&gt;3
6--&gt;7
</code></pre><p>这里增加了上下界判断条件，通过根节点的值为条件不断添加上下界。</p>
          </div>

<p>当然迭代也是可以的，这里不写了。思路和蓝色注释部分是一样的。</p>
<h4 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h4><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 <code>1</code> 开始计数）。</p>
<p>示例：<br><img src="kthtree1.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>root = [3,1,4,null,2], k = 1</code><br>    输出：<code>1</code></p>
<p>牢记BST的中序遍历呈升序排列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        TreeNode temp;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>          <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(root);<br>            root = root.left;<br>          &#125;<br>          root = stack.pop();<br>          <span class="hljs-keyword">if</span>(counter == k)<br>            <span class="hljs-keyword">return</span> root.val;<br>          counter++;<br>          root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><p>给定一个二叉树的 根节点 <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例：<br><img src="tmpd5jn43fs-1.png" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>root = [1,2,3,null,5,null,4]</code><br>    输出：<code>[1,3,4]</code></p>
<div class="note note-info">
            <p>我是sb，最🤡的一次，明明知道了出来的是同高度最右边的那个，结果敲了半天的中序遍历🤡🤡🤡。然后看评论是层序遍历，一语惊醒梦中人。如果是中序遍历，高度根本不好找。知道了可以用层序遍历，10分钟就敲完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        TreeNode temp;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>, size;<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            size = queue.size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                temp = queue.poll();<br>                <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-literal">null</span>)<br>                    queue.offer(temp.left);<br>                <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-literal">null</span>)<br>                    queue.offer(temp.right);<br>                node = temp.val;<br>                size--;<br>            &#125;<br>            ans.add(node);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<p>官方题解是基于dfs的递归实现，我们总是先访问右子树，这样出来的就是最右边的结点了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_depth</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>        Deque&lt;TreeNode&gt; nodeStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        Deque&lt;Integer&gt; depthStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        nodeStack.push(root);<br>        depthStack.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (!nodeStack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nodeStack.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> depthStack.pop();<br><br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                max_depth = Math.max(max_depth, depth);<br><br>                <span class="hljs-keyword">if</span> (!rightmostValueAtDepth.containsKey(depth))<br>                    rightmostValueAtDepth.put(depth, node.val);<br><br>                nodeStack.push(node.left);<br>                nodeStack.push(node.right);<br>                depthStack.push(depth + <span class="hljs-number">1</span>);<br>                depthStack.push(depth + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        List&lt;Integer&gt; rightView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; depth &lt;= max_depth; depth++)<br>            rightView.add(rightmostValueAtDepth.get(depth));<br><br>        <span class="hljs-keyword">return</span> rightView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</li>
</ul>
<p>示例：<br><img src="flaten.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>root = [1,2,5,3,4,null,6]</code><br>    输出：<code>[1,null,2,null,3,null,4,null,5,null,6]</code></p>
<div class="note note-info">
            <p>简简单单的递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        flatten(root.right);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        flatten(root.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left, right = root.right;<br>        <span class="hljs-keyword">while</span>(temp.right != <span class="hljs-literal">null</span>)<br>            temp = temp.right;<br>        root.right = root.left;<br>        root.left = <span class="hljs-literal">null</span>;<br>        temp.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<p>最简单的办法就是先序遍历，然后在先序遍历的过程中一个个加链表的值。如果执意要实现$O(1)$空间复杂度的话，就需要寻找前驱节点。<br>前驱节点的具体做法是</p>
<ul>
<li>对于当前节点，若左节点不为空，则寻找左子树最右边的节点，作为前驱节点</li>
</ul>
<pre><code class=" mermaid">flowchart TD
cur[cur]
pre[pre]
next[next]

subgraph tree[tree]
one[1]
two[2]
three[3]
four[4]
five[5]
six[6]
end

one--&gt;two--&gt;three
two--&gt;four
one--&gt;five--&gt;six

cur-.-&gt;one
next-.-&gt;two
pre-.-&gt;four
</code></pre>

<ul>
<li>当前节点的右子节点赋给前驱节点的右子节点</li>
</ul>
<pre><code class=" mermaid">flowchart TD
cur[cur]
pre[pre]
next[next]

subgraph tree[tree]
one[1]
two[2]
three[3]
four[4]
five[5]
six[6]
end

one--&gt;two--&gt;three
two--&gt;four
four--&gt;five--&gt;six

cur-.-&gt;one
next-.-&gt;two
pre-.-&gt;four
</code></pre>

<ul>
<li>当前节点的左子节点赋给当前节点的右子节点，左子节点赋空</li>
</ul>
<pre><code class=" mermaid">flowchart TD
cur[cur]
pre[pre]
next[next]


subgraph tree[tree]
null[null]
one[1]
two[2]
three[3]
four[4]
five[5]
six[6]
end

one-.-&gt;null
one--&gt;two--&gt;three
two--&gt;four
four--&gt;five--&gt;six

cur-.-&gt;one
next-.-&gt;two
pre-.-&gt;four
</code></pre>

<ul>
<li>继续处理下一节点(即cur移动到2)</li>
</ul>
<p>故最后的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curr.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.left;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> next;<br>                <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-literal">null</span>) &#123;<br>                    pre = pre.right;<br>                &#125;<br>                pre.right = curr.right;<br>                curr.left = <span class="hljs-literal">null</span>;<br>                curr.right = next;<br>            &#125;<br>            curr = curr.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的先序遍历， <code>inorder</code> 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p>示例：<br><img src="tree.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入: <code>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</code><br>    输出: <code>[3,9,20,null,null,15,7]</code></p>
<p>先序遍历的第一个数一定是根节点，中序遍历中根节点的左边一定在左子树上，而这篇数据在先序遍历中也一定是连续的，因此可以通过某种手段将这两个序列分成两半，分别对应左子树和右子树。然后通过递归或迭代生成对应结果。</p>
<div class="note note-info">
            <p>先前写的C++的代码。该题不难，主要是比较复杂。学校数据结构oj也有原题，但给的参数是数组，数组的分割和参数传递极其简单，算是给降难度了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">empty</span>() || inorder.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val = preorder[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">auto</span> it_in = inorder.<span class="hljs-built_in">begin</span>(), it_pre = preorder.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(; *it_in != root_val; ++it_in);<br>        vector&lt;<span class="hljs-type">int</span>&gt; left_inorder, right_inorder, left_preorder, right_preorder;<br>        <span class="hljs-keyword">if</span>(it_in != inorder.<span class="hljs-built_in">begin</span>())<br>            left_inorder.<span class="hljs-built_in">insert</span>(left_inorder.<span class="hljs-built_in">end</span>(), inorder.<span class="hljs-built_in">begin</span>(), it_in);<br>        <span class="hljs-keyword">if</span>(it_in != inorder.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>)<br>            right_inorder.<span class="hljs-built_in">insert</span>(right_inorder.<span class="hljs-built_in">end</span>(), it_in + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        left_preorder.<span class="hljs-built_in">insert</span>(left_preorder.<span class="hljs-built_in">end</span>(), it_pre, it_pre + left_inorder.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">if</span>(it_pre != preorder.<span class="hljs-built_in">end</span>())<br>            right_preorder.<span class="hljs-built_in">insert</span>(right_preorder.<span class="hljs-built_in">end</span>(), it_pre + left_inorder.<span class="hljs-built_in">size</span>(), preorder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val, <span class="hljs-built_in">buildTree</span>(left_preorder, left_inorder), <span class="hljs-built_in">buildTree</span>(right_preorder, right_inorder));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
          </div>

<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 $O(1)$ 的时间对根节点进行定位了。</p>
<p>以下为递归法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorder_root</span> <span class="hljs-operator">=</span> preorder_left;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_root]);<br>        <br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_left_subtree</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            indexMap.put(inorder[i], i);<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p>看到题解的递归传参也这么丑陋我就放心了</p>
          </div>

<p>以下为迭代法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder == <span class="hljs-literal">null</span> || preorder.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        stack.push(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorderIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preorder.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preorderVal</span> <span class="hljs-operator">=</span> preorder[i];<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-keyword">if</span> (node.val != inorder[inorderIndex]) &#123;<br>                node.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorderVal);<br>                stack.push(node.left);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;<br>                    node = stack.pop();<br>                    inorderIndex++;<br>                &#125;<br>                node.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorderVal);<br>                stack.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对前序遍历某个连续的节点<code>u</code>和<code>v</code>，只有两种可能的关系</p>
<ul>
<li><p><code>v</code>是<code>u</code>的左儿子</p>
</li>
<li><p><code>u</code>没有左儿子，并且<code>v</code>是<code>u</code>的某个祖先节点（或者<code>u</code>本身）的右儿子。</p>
<ul>
<li>若<code>u</code>没有左儿子，那么<code>v</code>就是<code>u</code>的右儿子</li>
<li>若<code>u</code>没有右儿子，那么可以向上追溯，直到遇到第一个有右儿子的节点。该节点的右儿子就是<code>v</code></li>
</ul>
</li>
</ul>
<div class="note note-primary">
            <p>题解中的例子如下</p><p>我们以树</p><pre><code class=" mermaid">graph TD
3--&gt;9--&gt;8--&gt;5--&gt;4
8--&gt;10
3--&gt;20--&gt;15
20--&gt;7
</code></pre><p>和其遍历</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br><span class="hljs-attr">inorder</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>为例。我们使用栈和指针进行维护。</p><ul><li>栈压入根节点3，指针指向4</li><li>遍历9，9不等于栈顶3，因此9是3的左儿子，入栈<br>  假如9是3的右儿子，那么由于先序遍历，3没有左儿子。这与中序遍历开头不是3相矛盾</li><li>遍历8、5、4同理，是上一节点的左儿子，入栈 <code>stack=[3 9 8 5 4] *index=4</code></li><li>遍历10，此时栈顶为4，和中序一样了，那么4没有左儿子。那么10一定是栈中某个节点的右儿子<br>  如何找到这个节点呢？我们可以把指针不断移动，同时弹出栈顶节点（若栈顶节点等于指针指向值），直到指针指向值不等于栈顶值(此例中为<code>stack=[3 9] *index=10</code>)。不等于时，说明 10 就是弹出的最后一个节点 8 的右儿子<br>  8在此时是根节点，中序遍历中遍历完8后会先遍历其右儿子10，而先序遍历中会先遍历完左儿子再遍历枝杈，这就是二者不同的原因<br>  最后把10入栈 <code>stack=[3 9 10] *index=10</code></li><li>遍历到20，刚好又和栈顶10相等，弹出9、3，栈空，因此20是3的右儿子。20入栈 <code>stack=[20] *index=15</code></li><li>遍历15与栈顶20不等，入栈 <code>stack=[20 15] *index=15</code></li><li>遍历7，指针指向值刚好是15，弹出15和20，栈空，因此7为20的右儿子</li><li>遍历结束</li></ul>
          </div>

<p>于是，我们可以用一个栈辅助进行二叉树的构造，栈的含义为“当前节点的所有还没有考虑过右儿子的祖先节点”。初始时栈中存放了根节点（前序遍历第一个节点），指针指向中序遍历的第一个节点，该指针对应的节点是“当前节点不断往左走达到的最终节点”。<br>我们依次枚举前序遍历中除了第一个节点以外的每个节点。若指针恰好指向栈顶，那么我们不断地弹出栈顶节点并向右移动指针，并将当前节点作为最后一个弹出节点的右儿子。若指针和栈顶节点不同，我们将当前节点作为栈顶节点的右儿子。<br>无论哪一种情况，我们最后都将当前的节点入栈。</p>
<h4 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h4><p>给定一个二叉树根节点<code>root</code>，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。<br><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>示例：<br><img src="pathsum3-1-tree.jpg" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：<code>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</code><br>    输出：<code>3</code><br>    解释：和等于 <code>8</code> 的路径有 <code>3</code> 条，如图所示。</p>
<h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>使用dfs递归肯定是最自然的，但怎么实现是个问题。太简单的递归容易多算情况。</p>
<ul>
<li>我们首先定义<code>rootSum(p,val)</code>表示以节点<code>p</code>为起点向下且满足路径总和为<code>val</code>的路径数目（而非使用自带函数递归），对二叉树上每个节点<code>p</code>求出<code>rootSum(p,val)</code>，然后对这些路径数目求合就是结果。</li>
<li>对节点<code>p</code>求<code>rootSum(p,targetSum)</code>时，以当前节点<code>p</code>为目标路径的起点递归向下进行搜索。假设当前的节点<code>p</code>的值为<code>val</code>，我们对左子树合右子树进行递归搜索，对其左孩子节点求出<code>rootSum(p.left,targetSum - val)</code>，右孩子同理。最后求和。同时我们还需要判断一下节点本身是否刚好等于<code>targetSum</code>。</li>
<li>采用递归遍历二叉树每个节点<code>p</code>，求<code>rootSum(p,val)</code>，然后将每个节点所有求的值进行相加求和并返回。</li>
</ul>
<p>简单来说，<code>pathSum</code>的递归是对每一条可能的不同路径进行递归，而<code>rootSum</code>的递归是对某条特定路径进行求值。由此可以避免出现求多情况的可能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> rootSum(root, targetSum);<br>        ret += pathSum(root.left, targetSum);<br>        ret += pathSum(root.right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rootSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-keyword">if</span> (val == targetSum)<br>            ret++;<br>        ret += rootSum(root.left, targetSum - val);<br>        ret += rootSum(root.right, targetSum - val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h5><p>此此方法可以把时间复杂度由$O(n^2)$降到$O(n)$。<br>我们定义前缀和为，由根节点到当前节点的路径上，所有节点的和。</p>
<ul>
<li>先序遍历二叉树，记录下根节点到当前节点的路径上，除当前节点意外所有节点的前缀和。在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和</li>
<li>空路径也需要保存预先处理一下。因为空路径不经过任何节点，因此它的前缀和为0</li>
<li>其他路径的前缀和由节点到根节点的数据相减获得</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        Map&lt;Long, Integer&gt; prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Long, Integer&gt;();<br>        prefix.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, prefix, <span class="hljs-number">0</span>, targetSum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="hljs-type">long</span> curr, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        curr += root.val;<br><br>        ret = prefix.getOrDefault(curr - targetSum, <span class="hljs-number">0</span>);<br>        prefix.put(curr, prefix.getOrDefault(curr, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        ret += dfs(root.left, prefix, curr, targetSum);<br>        ret += dfs(root.right, prefix, curr, targetSum);<br>        prefix.put(curr, prefix.getOrDefault(curr, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码中的<code>curr</code>即为前缀和。一开始先更新前缀和数据。然后检查有多少个祖先节点满足条件（即从根节点到某个祖先节点的路径）,赋值给<code>ret</code></p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">根节点 → A → B →</span> <span class="hljs-title">[</span><span class="hljs-comment">当前节点</span><span class="hljs-title">]</span><br><span class="hljs-comment">|</span><span class="hljs-literal">-----</span> <span class="hljs-comment">前缀和=7</span> <span class="hljs-literal">-----</span><span class="hljs-comment">|      (祖先节点路径)</span><br><span class="hljs-comment">|</span><span class="hljs-literal">----------</span> <span class="hljs-comment">前缀和=15</span> <span class="hljs-literal">---------</span><span class="hljs-comment">| (当前路径)</span><br>          <span class="hljs-comment">|</span><span class="hljs-literal">-----</span> <span class="hljs-comment">8</span> <span class="hljs-literal">-----</span><span class="hljs-comment">|      (有效路径：B的下一个节点 → 当前节点)</span><br></code></pre></td></tr></table></figure>

<p><code>curr - targetSum = 15 - 8 = 7</code></p>
<p>查找前缀和为7的出现次数，若结果为2，则说明存在2个不同的祖先节点，<code>节点-&gt;当前节点</code>的路径和为8。</p>
<h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>示例：<br><img src="./leetcode-3/binarytree.png" srcset="/img/loading.gif" lazyload alt="示例"><br>    输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>    输出：3<br>    解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>遍历整棵二叉树，定义$f_x$表示$x$节点的子树是否包含$p$节点或$q$节点。需要最近公共祖先满足以下条件<br>$$<br>(f_{lson} \cap f_{rson}) \cup ((x&#x3D;p\cup x&#x3D;q)\cap (f_{lson}\cup f_{rson}))<br>$$</p>
<div class="note note-success">
            <p>也就是说，需要这个节点</p><ul><li>同时有左右孩子，并且两个子树上都有要求的节点</li><li>自己本身等于一个值，并且有一个子树上有要求的节点</li></ul>
          </div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TreeNode ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.ans = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">lson</span> <span class="hljs-operator">=</span> dfs(root.left, p, q);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">rson</span> <span class="hljs-operator">=</span> dfs(root.right, p, q);<br>        <span class="hljs-keyword">if</span> ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson)))<br>            ans = root;<br>        <span class="hljs-keyword">return</span> lson || rson || (root.val == p.val || root.val == q.val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dfs(root, p, q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="存储父节点"><a href="#存储父节点" class="headerlink" title="存储父节点"></a>存储父节点</h5><ul>
<li>从根节点遍历整棵二叉树，用哈希表记录每个节点的父节点指针</li>
<li>从$p$节点开始不断往它的祖先移动，并用数据结构记录已访问过的祖先节点</li>
<li>对$q$同理，但是，若有祖先已经被访问过，那么返回这个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, TreeNode&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, TreeNode&gt;();<br>    Set&lt;Integer&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            parent.put(root.left.val, root);<br>            dfs(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            parent.put(root.right.val, root);<br>            dfs(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            visited.add(p.val);<br>            p = parent.get(p.val);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(q.val))<br>                <span class="hljs-keyword">return</span> q;<br>            q = parent.get(q.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树中最大的路径和"><a href="#二叉树中最大的路径和" class="headerlink" title="二叉树中最大的路径和"></a>二叉树中最大的路径和</h4><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。<strong>路径和</strong> 是路径中各节点值的总和。给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><p>考虑一个函数<code>maxGain(node)</code>，计算二叉树某个节点的最大贡献值，也就是说，以该节点为根节点的子树中，寻找以该节点为起点的一条路径，使得该路径上的节点之和最大。<br>计算方式如下</p>
<ul>
<li>空姐点的最大贡献值为0</li>
<li>非空节点的最大贡献值等于该节点与其子节点中的最大贡献值之和（叶节点则为节点值本身）</li>
</ul>
<p>对于以下子树</p>
<pre><code class=" mermaid">graph TD
-10--&gt;9
-10--&gt;20--&gt;15
20--&gt;7
</code></pre>

<p><code>9</code> <code>15</code> <code>7</code>的最大贡献值是其本身，<code>20</code>的贡献值为<code>20 + max(15,7) = 35</code>，节点<code>-10</code>的最大贡献值为<code>-10 + max(9,35) = 25</code>。<br>计算完每个节点的最大贡献值后，某节点的最大路径和取决于该节点的值和这个节点的左右子节点的最大贡献值。若子节点的最大贡献值为正，那么就计入该节点的最大路径和。维护变量存贮最大路径和并不断更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        maxGain(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxGain</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftGain</span> <span class="hljs-operator">=</span> Math.max(maxGain(node.left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightGain</span> <span class="hljs-operator">=</span> Math.max(maxGain(node.right), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">priceNewpath</span> <span class="hljs-operator">=</span> node.val + leftGain + rightGain;<br>        maxSum = Math.max(maxSum, priceNewpath);<br>        <span class="hljs-keyword">return</span> node.val + Math.max(leftGain, rightGain);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="数组中第K个最大的元素"><a href="#数组中第K个最大的元素" class="headerlink" title="数组中第K个最大的元素"></a>数组中第K个最大的元素</h4><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。<br>你必须设计并实现时间复杂度为 $O(n)$ 的算法解决此问题。</p>
<h5 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h5><p><a href="https://ivanclf.github.io/2024/12/30/data-structure-1/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">有关快排的内容可以看这里</a><br>快排需要进行划分操作，而每次划分后，对于子数组<code>a[l...q-1]</code>中的每个元素，都小于<code>a[q]</code>，且<code>a[q]</code>小于<code>a[q+1...r]</code>中的每个元素，因此，只要某次划分的<code>q</code>为倒数第<code>k</code>个下标的时候，我们就找到了答案。<br>因此在划分中，若划分的<code>q</code>恰好就是需要的数，就返回<code>a[q]</code>；若<code>q</code>比目标下标小，就递归右区间，否则递归左区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">quickselect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[l], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt;= j) <span class="hljs-keyword">return</span> quickselect(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> quickselect(nums, j + <span class="hljs-number">1</span>, r, k);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> _nums.length;<br>        <span class="hljs-keyword">return</span> quickselect(_nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n - k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>quickselect()</code>函数中，第二第三个参数是数组的指定区间，最后一个参数为指定元素的索引。在入口函数<code>findKthLargest()</code>中，寻找的是第<code>k</code>大的元素在升序数组中的位置<code>n - k</code>。以最左元素<code>nums[l]</code>为基准，</p>
<ul>
<li>初始化指针<code>i = l - 1</code>和<code>j = r + 1</code></li>
<li>移动<code>i</code>直到找到不小于基准的元素，移动<code>j</code>直到找到不大于基准的元素</li>
<li>交换<code>i</code>和<code>j</code>的元素，确保左侧元素不大于基准，右侧元素不小于基准</li>
</ul>
<p>这其实就是快排的过程。然后自然就是递归。但我们只需要找出对应元素即可，因此可以递归半边。若<code>k &lt;= j</code>，说明目标在左半部分，只需递归左半部分即可，右边同理。<br>平均时间复杂度为$O(n)$</p>
<h5 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h5><p>建立一个大根堆，做$k-1$次删除操作后堆顶的元素就是我们要找的答案。<br><a href="https://ivanclf.github.io/2024/12/30/data-structure-1/#%E5%A0%86%E6%8E%92%E5%BA%8F">有关堆排序的内容可以看这里</a><br>大根堆中，每个节点的值都大于等于其节点的值。代码首先将数组重新排列成一个最大堆，然后每次我们拿走塔顶的数字（最大值），然后重新调整金字塔，让下一个最大的数字升到塔顶，重复K次后就是最后结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">heapSize</span> <span class="hljs-operator">=</span> nums.length;<br>        buildMaxHeap(nums, heapSize);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= nums.length - k + <span class="hljs-number">1</span>; --i) &#123;<br>            swap(nums, <span class="hljs-number">0</span>, i);<br>            --heapSize;<br>            maxHeapify(nums, <span class="hljs-number">0</span>, heapSize);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> heapSize / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            maxHeapify(a, i, heapSize);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maxHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, largest = i;<br>        <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest])<br>            largest = l;<br>        <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest])<br>            largest = r;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            swap(a, i, largest);<br>            maxHeapify(a, largest, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度为$O(n \log n)$</p>
<h4 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。<br>你所设计算法的时间复杂度 <strong>必须</strong> 优于 $O(n \log n)$ ，其中 <code>n</code> 是数组大小。</p>
<h5 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h5><p>维护一个“出现次数数组”，建立一个小顶堆，然后给这个“出现次数数组”排序。</p>
<ul>
<li>若堆的元素个数小于k，就直接插入堆中</li>
<li>若堆的元素个数等于k，就检查堆顶与当前出现次数的大小，堆顶值更小时就弹出堆顶，并将当前值插入堆中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; occurrences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            occurrences.put(num, occurrences.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k)<br>                <span class="hljs-keyword">if</span> (queue.peek()[<span class="hljs-number">1</span>] &lt; count) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            <span class="hljs-keyword">else</span><br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            ret[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p><code>PriorityQueue</code>是一个优先队列，在Java中默认是一个小顶堆，中间的<code>Comparator&lt;int[]&gt;</code>是其优先级插队规则（按出现次数排序）<br><code>Map.Entry&lt;Integer, Integer&gt; entry</code>表示<code>Map</code>的一个键值对</p>
          </div>

<h5 id="快排-1"><a href="#快排-1" class="headerlink" title="快排"></a>快排</h5><p>在进行划分时，根据k与左侧子数组的长度<code>q - i</code>的大小关系</p>
<ul>
<li>若<code>k &lt;= q - i</code>，则数组<code>arr[i...r]</code>前k大的值就等于数组<code>arr[i...q - 1]</code>中前k大的值</li>
<li>否则，数组<code>arr[i...r]</code>前k大的值，就等于左侧子数组的全部元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; occurrences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            occurrences.put(num, occurrences.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            values.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        qsort(values, <span class="hljs-number">0</span>, values.size() - <span class="hljs-number">1</span>, ret, <span class="hljs-number">0</span>, k);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>[]&gt; values, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] ret, <span class="hljs-type">int</span> retIndex, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">picked</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * (end - start + <span class="hljs-number">1</span>)) + start;<br>        Collections.swap(values, picked, start);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> values.get(start)[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>; i &lt;= end; i++)<br>            <span class="hljs-keyword">if</span> (values.get(i)[<span class="hljs-number">1</span>] &gt;= pivot) &#123;<br>                Collections.swap(values, index + <span class="hljs-number">1</span>, i);<br>                index++;<br>            &#125;<br>        Collections.swap(values, start, index);<br><br>        <span class="hljs-keyword">if</span> (k &lt;= index - start)<br>            qsort(values, start, index - <span class="hljs-number">1</span>, ret, retIndex, k);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= index; i++)<br>                ret[retIndex++] = values.get(i)[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (k &gt; index - start + <span class="hljs-number">1</span>)<br>                qsort(values, index + <span class="hljs-number">1</span>, end, ret, retIndex, k - (index - start + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-success">
            <p>讽刺的是这两个官方题解都没过。</p>
          </div>

<h4 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h4><p>实现 <code>MedianFinder</code> 类:</p>
<ul>
<li><code>MedianFinder()</code> 初始化 <code>MedianFinder</code> 对象。</li>
<li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li>
<li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 $10^{-5}$ 以内的答案将被接受。</li>
</ul>
<p>用两个优先队列<code>queMax</code>和<code>queMin</code>来存比中位数小的数和大于等于中位数的数。<br>当累计添加的数量为奇数时，<code>queMin</code>中的数量比<code>queMax</code>多一个，此时中位数为<code>queMin</code>的队头；为偶数时中位数为两个优先队列的平均数。特别地，当累计添加的数据为0时，先将数据加到小的那半。<br>尝试添加一个数时，若数字小于<code>queMin</code>中的中位数，就将这个数添加到<code>queMin</code>中，否则加到<code>queMax</code>中。若两个堆的元素数量尽量平衡，若不平衡（相差超过1）就把多的那堆放一个数据到另一边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; queMin;<br>    PriorityQueue&lt;Integer&gt; queMax;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        queMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; (b - a));<br>        queMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; (a - b));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (queMin.isEmpty() || num &lt;= queMin.peek()) &#123;<br>            queMin.offer(num);<br>            <span class="hljs-keyword">if</span> (queMax.size() + <span class="hljs-number">1</span> &lt; queMin.size())<br>                queMax.offer(queMin.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queMax.offer(num);<br>            <span class="hljs-keyword">if</span> (queMax.size() &gt; queMin.size())<br>                queMin.offer(queMax.poll());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (queMin.size() &gt; queMax.size())<br>            <span class="hljs-keyword">return</span> queMin.peek();<br>        <span class="hljs-keyword">return</span> (queMin.peek() + queMax.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>leetcode热题100官方题解 - 3</div>
      <div>https://ivanclf.github.io/2025/08/13/leetcode-3/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ivan Chan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="../../16/leetcode-4/" title="leetcode热题100官方题解 - 4">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">leetcode热题100官方题解 - 4</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../08/leetcode-2/" title="leetcode热题100官方题解 - 2">
                        <span class="hidden-mobile">leetcode热题100官方题解 - 2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default","securityLevel":"loose"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
